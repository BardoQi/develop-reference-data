//*------------------------------------------------------------------------------------------------
//* 文件名				: os_api.c
//* 功能描述				: 基于uC/OS基本函数库开发的能够最大限度满足上层系统需求的API。
//* 作者    				: 焦海波
//* 版本					: 0.1
//* 建立日期、时间		: 2006/06/10 10:45
//* 最近修改日期、时间	: 
//* 修改原因				: 
//*------------------------------------------------------------------------------------------------
//*------------------------------------------ 头文件 -----------------------------------------------
//#include	"/uCOS_II/SOURCE/includes.h"
#include	"os_api.h"
//*================================================================================================
//*											函	数	区
//*================================================================================================
//*------------------------------------------------------------------------------------------------
//* 函数名称 : OSAPISemWait
//* 功能描述 : 在指定的时间内（单位为毫秒）等待指定的信号量可用
//* 入口参数 :     <hSem>[in] 等待的信号量句柄
//*			 : <uwWaitMS>[in] 指定最长等待时间单位为毫秒，实际等待时间为内核调度间隔时间的整数倍，
//*			 :                0ms表示该函数将无限期等待下去直至信号量可用
//* 出口参数 : - OS_NO_ERR         : 信号量可用
//*			 : - OS_TIMEOUT        : 时间溢出，信号量不可用
//*			 : - OS_ERR_EVENT_TYPE : hSem参数携带的事件类型并不是信号量而是其它类型
//*			 : - OS_ERR_PEND_ISR   : 不能在ISR中调用该函数
//*			 : - OS_ERR_PEVENT_NULL: hSem是一个空指针
//*------------------------------------------------------------------------------------------------

#define NULL 0
UBYTE OSAPISemWait(HANDLER hSem, UWORD uwWaitMS)
{
	UWORD	__uwDelayTicks;
	UBYTE	__ubRtnVal;
	
	if(uwWaitMS != 0)
	{
		__uwDelayTicks = (uwWaitMS * OS_TICKS_PER_SEC)/1000;
		if(__uwDelayTicks < 1)
			__uwDelayTicks = 1;
		else if(__uwDelayTicks > 65535)
			__uwDelayTicks = 65535;
		else;
	}
	else
		__uwDelayTicks = 0;
		
	OSSemPend(hSem, __uwDelayTicks, &__ubRtnVal);
	
	return __ubRtnVal;
}
//*------------------------------------------------------------------------------------------------
//* 函数名称	: OSAPISemFree
//* 功能描述	: 删除指定的信号量，如果仍然有任务在等待指定的信号量，该函数不会删除这个信号量，不过它会不断尝
//*			: 试删除这个信号量直至没有任何任务等待该信号量时将其删除
//* 入口参数	:      <hSem>[in] 指定删除的信号量句柄
//* 出口参数	: 无
//*------------------------------------------------------------------------------------------------
void OSAPISemFree(HANDLER hSem)
{
	UBYTE	__ubErr;
	
	while(NULL != OSSemDel(hSem, OS_DEL_NO_PEND, &__ubErr))
		OSTimeDlyHMSM(0, 0, 0, 100);
}
//*------------------------------------------------------------------------------------------------
//* 函数名称	: OSAPISemFreeExt
//* 功能描述	: 删除指定的信号量，该函数相对于OSAPISemFree()函数，当出现仍然有任务在等待该信号量的情况时，所
//*			: 有等待该信号量的任务都将进入就绪态，每个任务都得到了该信号量。
//* 入口参数	:      <hSem>[in] 指定删除的信号量句柄
//* 出口参数	: 无
//*------------------------------------------------------------------------------------------------
void OSAPISemFreeExt(HANDLER hSem)
{
	UBYTE	__ubErr;
	
	while(NULL != OSSemDel(hSem, OS_DEL_ALWAYS, &__ubErr))
		OSTimeDlyHMSM(0, 0, 0, 100);
}
//*------------------------------------------------------------------------------------------------
//* 函数名称	: OSAPIBlockNew
//* 功能描述	: 建立一个新的阻塞信号
//* 入口参数	: <ubPIP>[in] 指定在出现优先级反转时（高优先级的任务因为低优先级的任务占用同一个阻塞量而不得不
//*			:             暂时中断正常运行以等待该阻塞量被释放从而造成事实上的优先级降低的问题），正在占用
//*			:             该阻塞量的任务使用的较高优先级以便能够快速完成访问，释放该阻塞量 
//* 出口参数	: 建立成功返回阻塞信号句柄，否则为NULL
//*------------------------------------------------------------------------------------------------
HANDLER OSAPIBlockNew(UBYTE ubPIP)
{
	UBYTE		__ubErr;
	
	return OSMutexCreate(ubPIP, &__ubErr);
}
//*------------------------------------------------------------------------------------------------
//* 函数名称	: OSAPIBlockEnter
//* 功能描述	: 进入阻塞资源，如果该资源仍然被其它任务占用，则会阻塞当前任务进程，直至指定的时间溢出或者资源
//*         : 可用
//* 入口参数	:   <hBlock>[in] 指定要使用的阻塞信号量
//*			: <uwWaitMS>[in] 指定被阻塞的最长时间，单位为毫秒 
//* 出口参数	: - OS_NO_ERR         : 信号量可用
//*			: - OS_TIMEOUT        : 时间溢出，信号量不可用
//*			: - OS_ERR_EVENT_TYPE : hSem参数携带的事件类型并不是信号量而是其它类型
//*			: - OS_ERR_PEND_ISR   : 不能在ISR中调用该函数
//*			: - OS_ERR_PEVENT_NULL: hSem是一个空指针
//*------------------------------------------------------------------------------------------------
UBYTE OSAPIBlockEnter(HANDLER hBlock, UWORD uwWaitMS)
{
	UWORD	__uwDelayTicks;
	UBYTE	__ubRtnVal;
	
	if(uwWaitMS != 0)
	{
		__uwDelayTicks = (uwWaitMS * OS_TICKS_PER_SEC)/1000;
		if(__uwDelayTicks < 1)
			__uwDelayTicks = 1;
		else if(__uwDelayTicks > 65535)
			__uwDelayTicks = 65535;
		else;
	}
	else
		__uwDelayTicks = 0;
		
	OSMutexPend(hBlock, __uwDelayTicks, &__ubRtnVal);
	
	return __ubRtnVal;
}