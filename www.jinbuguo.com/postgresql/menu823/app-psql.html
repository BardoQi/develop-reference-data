<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="zh-CN"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta http-equiv="Content-Language" content="zh-CN"><link href="stylesheet.css" media="all" rel="stylesheet" type="text/css">
<title>psql</title>
<script>var _hmt=_hmt||[]; (function(){ var hm=document.createElement("script"); hm.src="//hm.baidu.com/hm.js?d286c55b63a3c54a1e43d10d4c203e75"; var s=document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm,s); })();</script>
</head><body class="REFENTRY">
<div>
<table summary="Header navigation table" width="100%" border="0" cellpadding="0" cellspacing="0">
<tr><th colspan="5" align="center" valign="bottom">PostgreSQL 8.2.3 中文文档</th></tr>
<tr><td width="10%" align="left" valign="top"><a href="app-pgrestore.html" accesskey="P">后退</a></td><td width="10%" align="left" valign="top"><a href="app-pgrestore.html">快退</a></td><td width="60%" align="center" valign="bottom"></td><td width="10%" align="right" valign="top"><a href="app-reindexdb.html">快进</a></td><td width="10%" align="right" valign="top"><a href="app-reindexdb.html" accesskey="N">前进</a></td></tr>
</table>
<hr align="LEFT" width="100%"></div>
<h1><a name="APP-PSQL"></a><span class="APPLICATION">psql</span></h1>
<div class="REFNAMEDIV"><a name="AEN58117"></a><h2>名称</h2><span class="APPLICATION">psql</span>&nbsp;--&nbsp;PostgreSQL 交互终端</div>
<a name="AEN58122"></a>
<div class="REFSYNOPSISDIV"><a name="AEN58124"></a><h2>语法</h2>
<p><tt class="COMMAND">psql</tt> [<tt class="REPLACEABLE"><i>option</i></tt>...] [<tt class="REPLACEABLE"><i>dbname</i></tt> [<tt class="REPLACEABLE"><i>username</i></tt>]]</p>
</div>
<div class="REFSECT1"><a name="AEN58133"></a><h2>描述</h2>
<p><span class="APPLICATION">psql</span> 是一个以终端为基础的 PostgreSQL 前端。它允许你交互地键入查询，然后把它们发出给 PostgreSQL ，再显示查询的结果。另外，输入可以来自一个文件。还有，它提供了一些元命令和多种类似 shell 的特性来实现书写脚本以及对大量任务的自动化。</p>
</div>
<div class="REFSECT1"><a name="R1-APP-PSQL-3"></a><h2>选项</h2>
<div class="VARIABLELIST">
<dl>
<dt><tt class="OPTION">-a</tt><br><tt class="OPTION">--echo-all</tt></dt>
<dd><p>在读取行时向标准输出打印所有内容。这个选项在脚本处理时比交互模式时更有用。这个选项等效于设置 <tt class="VARNAME">ECHO</tt> 变量为 <tt class="LITERAL">all</tt></p></dd>
<dt><tt class="OPTION">-A</tt><br><tt class="OPTION">--no-align</tt></dt>
<dd><p>切换为非对齐输出模式。缺省输出模式是对齐的。</p></dd>
<dt><tt class="OPTION">-c <tt class="REPLACEABLE"><i>command</i></tt></tt><br><tt class="OPTION">--command <tt class="REPLACEABLE"><i>command</i></tt></tt></dt>
<dd><p>声明 <span class="APPLICATION">psql</span> 将执行一条查询字符串 <tt class="REPLACEABLE"><i>command</i></tt> ，然后退出。这一点在 shell 脚本里很有用。</p>
<p><tt class="REPLACEABLE"><i>command</i></tt> 必须是一条完全可以被服务器分析的字符串(也就是不包含 <span class="APPLICATION">psql</span> 特有的特性)，或者是一个反斜杠命令。这样你就不会混合 SQL 和 <span class="APPLICATION">psql</span> 元命令。要想混合使用，你可以把字符串重定向到 <span class="APPLICATION">psql</span> 里，像这样：<tt class="LITERAL">echo '\x \\ SELECT * FROM foo;' | psql</tt> (<tt class="LITERAL">\\</tt> 用于隔开元命令)。</p>
<p>如果命令字符串包含多个 SQL 命令，那么他们将在一个事务里处理，除非在字符串里包含了明确的 <tt class="COMMAND">BEGIN</tt>/<tt class="COMMAND">COMMIT</tt> 命令把他们分成多个事务。这个和从 <span class="APPLICATION">psql</span> 的标准输入里给它填充相同字符串不同。</p></dd>
<dt><tt class="OPTION">-d <tt class="REPLACEABLE"><i>dbname</i></tt></tt><br><tt class="OPTION">--dbname <tt class="REPLACEABLE"><i>dbname</i></tt></tt></dt>
<dd><p>声明想要连接的数据库名称。等效于在命令行行上把 <tt class="REPLACEABLE"><i>dbname</i></tt> 声明为第一个非选项参数。</p></dd>
<dt><tt class="OPTION">-e</tt><br><tt class="OPTION">--echo-queries</tt></dt>
<dd><p>把所有发送给服务器的查询同时也回显到标准输出。等效于把变量 <tt class="VARNAME">ECHO</tt> 设置为 <tt class="LITERAL">queries</tt></p></dd>
<dt><tt class="OPTION">-E</tt><br><tt class="OPTION">--echo-hidden</tt></dt>
<dd><p>回显由 <tt class="COMMAND">\d</tt> 和其它反斜杠命令生成的实际查询。你可以使用这个命令学习 <span class="APPLICATION">psql</span> 的内部操作。这等效于在 <span class="APPLICATION">psql</span> 里设置变量 <tt class="VARNAME">ECHO_HIDDEN</tt> </p></dd>
<dt><tt class="OPTION">-f <tt class="REPLACEABLE"><i>filename</i></tt></tt><br><tt class="OPTION">--file <tt class="REPLACEABLE"><i>filename</i></tt></tt></dt>
<dd><p>使用 <tt class="REPLACEABLE"><i>filename</i></tt> 作为命令的语句源而不是交互式读入查询。<span class="APPLICATION">psql</span> 将在处理完文件后结束。这个选项在很多方面等效于内部命令 <tt class="COMMAND">\i</tt></p>
<p>如果 <tt class="REPLACEABLE"><i>filename</i></tt> 是 <tt class="LITERAL">-</tt>(连字符)，则从标准输入读取。</p>
<p>使用这个选项与使用 <tt class="LITERAL">psql &lt; <tt class="REPLACEABLE"><i>filename</i></tt></tt> 有微小的区别。通常，两者都回按照你预期那样运行，但是使用 <tt class="LITERAL">-f</tt> 打开了一些很好的特性，比如带行号的错误信息。而且，使用这个选项还可能减小启动的开销。另一方面，如果你把所有内容手工输入，使用 shell 输入定向的方式(理论上)能保证生成和你已经得到的完全一样的输出。</p></dd>
<dt><tt class="OPTION">-F <tt class="REPLACEABLE"><i>separator</i></tt></tt><br><tt class="OPTION">--field-separator <tt class="REPLACEABLE"><i>separator</i></tt></tt></dt>
<dd><p>使用 <tt class="REPLACEABLE"><i>separator</i></tt> 作为未对齐输出的域分隔符。等效于 <tt class="COMMAND">\pset fieldsep</tt> 或 <tt class="COMMAND">\f</tt></p></dd>
<dt><tt class="OPTION">-h <tt class="REPLACEABLE"><i>hostname</i></tt></tt><br><tt class="OPTION">--host <tt class="REPLACEABLE"><i>hostname</i></tt></tt></dt>
<dd><p>指定正在运行服务器的主机名。如果主机名以斜杠开头，则它被用作到 Unix 域套接字的路径。</p></dd>
<dt><tt class="OPTION">-H</tt><br><tt class="OPTION">--html</tt></dt>
<dd><p>打开 HTML 格式输出。等效于 <tt class="LITERAL">\pset format html</tt> 或 <tt class="COMMAND">\H</tt> 命令。</p></dd>
<dt><tt class="OPTION">-l</tt><br><tt class="OPTION">--list</tt></dt>
<dd><p>列出所有可用的数据库，然后退出。其它非连接选项将被忽略。类似于内部命令 <tt class="COMMAND">\list</tt></p></dd>
<dt><tt class="OPTION">-L <tt class="REPLACEABLE"><i>filename</i></tt></tt><br><tt class="OPTION">--log-file <tt class="REPLACEABLE"><i>filename</i></tt></tt></dt>
<dd><p>除了正常的输出源之外，把所有查询输出记录到文件 <tt class="REPLACEABLE"><i>filename</i></tt></p></dd>
<dt><tt class="OPTION">-o <tt class="REPLACEABLE"><i>filename</i></tt></tt><br><tt class="OPTION">--output <tt class="REPLACEABLE"><i>filename</i></tt></tt></dt>
<dd><p>将所有查询输出重定向到文件 <tt class="REPLACEABLE"><i>filename</i></tt> 。这个选项等效于 <tt class="COMMAND">\o</tt> 命令。</p></dd>
<dt><tt class="OPTION">-p <tt class="REPLACEABLE"><i>port</i></tt></tt><br><tt class="OPTION">--port <tt class="REPLACEABLE"><i>port</i></tt></tt></dt>
<dd><p>指定服务器侦听的 TCP 端口或本地 Unix 域套接字文件的扩展。缺省使用环境变量 <tt class="ENVAR">PGPORT</tt> 的值，如果没有设置的话则使用编译时声明的端口(通常是 5432)。</p></dd>
<dt><tt class="OPTION">-P <tt class="REPLACEABLE"><i>assignment</i></tt></tt><br><tt class="OPTION">--pset <tt class="REPLACEABLE"><i>assignment</i></tt></tt></dt>
<dd><p>允许你在命令行上以 <tt class="COMMAND">\pset</tt> 的风格设置打印选项。要注意的是你在这里必须用等号而不是空格分割名称和值。因此要把输出格式设置为 LaTeX ，你可以敲入 <tt class="LITERAL">-P format=latex</tt></p></dd>
<dt><tt class="OPTION">-q</tt><br><tt class="OPTION">--quiet</tt></dt>
<dd><p>安静地执行处理任务。缺省时 <span class="APPLICATION">psql</span> 将打印欢迎和许多其它输出信息。如果使用了此选项，这些都不会出现。这在和 <tt class="OPTION">-c</tt> 选项一起使用时很有效。在 <span class="APPLICATION">psql</span> 里可以通过设置 <tt class="VARNAME">QUIET</tt> 变量实现同样效果。</p></dd>
<dt><tt class="OPTION">-R <tt class="REPLACEABLE"><i>separator</i></tt></tt><br><tt class="OPTION">--record-separator <tt class="REPLACEABLE"><i>separator</i></tt></tt></dt>
<dd><p>使用 <tt class="REPLACEABLE"><i>separator</i></tt> 做为非对齐输出的记录分隔符。等效于 <tt class="COMMAND">\pset recordsep</tt> 命令。</p></dd>
<dt><tt class="OPTION">-s</tt><br><tt class="OPTION">--single-step</tt></dt>
<dd><p>单步模式运行。意味着每个查询在发往服务器之前都要提示用户，用这个选项也可以取消执行。此选项主要用于调试脚本。</p></dd>
<dt><tt class="OPTION">-S</tt><br><tt class="OPTION">--single-line</tt></dt>
<dd><p>单行运行模式，这时每个命令都将由换行符结束，像分号那样。</p>
<div class="NOTE">
<blockquote class="NOTE">
<p><b>【注意】</b>这个模式是给那些坚持要使用这个特性的人保留的，不鼓励你这么用。实际上，如果你在一行里混合使用 SQL 和元命令，执行的顺序对不熟练的用户而言并不总是清晰的。</p>
</blockquote>
</div></dd>
<dt><tt class="OPTION">-t</tt><br><tt class="OPTION">--tuples-only</tt></dt>
<dd><p>关闭打印列名称和结果行计数脚注等信息。等效于 <tt class="COMMAND">\t</tt> 命令。</p></dd>
<dt><tt class="OPTION">-T <tt class="REPLACEABLE"><i>table_options</i></tt></tt><br><tt class="OPTION">--table-attr <tt class="REPLACEABLE"><i>table_options</i></tt></tt></dt>
<dd><p>允许你声明放在 HTML <code class="SGMLTAG">table</code> 标签里的选项。参阅 <tt class="COMMAND">\pset</tt> 获取细节。</p></dd>
<dt><tt class="OPTION">-u</tt></dt>
<dd><p>强制 <span class="APPLICATION">psql</span> 在和数据库连接之前提示输入用户名和口令。</p>
<p>这个选项已经废弃了，因为它在概念上有漏洞。提示输入非缺省用户名和提示输入服务器要求的口令是完全两码事。鼓励你用 <tt class="OPTION">-U</tt> 和 <tt class="OPTION">-W</tt> 选项取代它。</p></dd>
<dt><tt class="OPTION">-U <tt class="REPLACEABLE"><i>username</i></tt></tt><br><tt class="OPTION">--username <tt class="REPLACEABLE"><i>username</i></tt></tt></dt>
<dd><p>以用户 <tt class="REPLACEABLE"><i>username</i></tt> 代替缺省用户与数据库连接。当然，你必须有这么做的权限。</p></dd>
<dt><tt class="OPTION">-v <tt class="REPLACEABLE"><i>assignment</i></tt></tt><br><tt class="OPTION">--set <tt class="REPLACEABLE"><i>assignment</i></tt></tt><br><tt class="OPTION">--variable <tt class="REPLACEABLE"><i>assignment</i></tt></tt></dt>
<dd><p>像内部命令 <tt class="COMMAND">\set</tt> 那样进行一次变量分配。注意，如果有变量名和值的话，你必须在命令行上用等号分隔它们。去掉等号则重置变量。要设置一个没有值的变量，可以保留等号但是不指定值。这个分配是在启动之初进行的，所以为内部使用而保留的变量可能被再次覆盖。</p></dd>
<dt><tt class="OPTION">-V</tt><br><tt class="OPTION">--version</tt></dt>
<dd><p>打印 <span class="APPLICATION">psql</span> 版本信息然后退出。</p></dd>
<dt><tt class="OPTION">-W</tt><br><tt class="OPTION">--password</tt></dt>
<dd><p>强制 <span class="APPLICATION">psql</span> 在与一个数据库连接前提示输入口令。</p>
<p>如果服务器要求口令认证，<span class="APPLICATION">psql</span> 将自动显示口令提示符。不过，目前是否需要输入口令的判断并不完全可靠，因此用这个选项强制显示这个提示符。如果没有发出口令提示符而服务器要求口令认证，那么连接企图将失败。</p>
<p>这个选项将在整个会话过程中有效，即使你用元命令 <tt class="COMMAND">\connect</tt> 改变了所连接的数据库。</p></dd>
<dt><tt class="OPTION">-x</tt><br><tt class="OPTION">--expanded</tt></dt>
<dd><p>打开扩展表格式模式。等效于 <tt class="COMMAND">\x</tt> 命令。</p></dd>
<dt><tt class="OPTION">-X,</tt><br><tt class="OPTION">--no-psqlrc</tt></dt>
<dd><p>不读取启动文件(系统范围的 <tt class="FILENAME">psqlrc</tt> 或者你自己的 <tt class="FILENAME">~/.psqlrc</tt> 都不读取)。</p></dd>
<dt><tt class="OPTION">-1</tt><br><tt class="OPTION">--single-transaction</tt></dt>
<dd><p>当 <span class="APPLICATION">psql</span> 使用 <tt class="OPTION">-f</tt> 选项执行脚本时，使用这个选项将导致在脚本的开头和结尾分别加上 <tt class="COMMAND">BEGIN</tt>/<tt class="COMMAND">COMMIT</tt> 来把整个脚本当作一个事务执行。这将保证该脚本要么完全执行成功，要么不产生任何影响。</p>
<p>如果在脚本中已经使用了 <tt class="COMMAND">BEGIN</tt>, <tt class="COMMAND">COMMIT</tt>, <tt class="COMMAND">ROLLBACK</tt> ，那么该选项将不会得到期望的效果。同样，如果脚本中包含任何不能在事务块内部使用的命令，使用这个选项将导致这样的命令执行失败，当然整个事务亦将失败。</p></dd>
<dt><tt class="OPTION">-?</tt><br><tt class="OPTION">--help</tt></dt>
<dd><p>显示关于 <span class="APPLICATION">psql</span> 命令行参数的帮助然后退出。</p></dd>
</dl>
</div>
</div>
<div class="REFSECT1"><a name="AEN58462"></a><h2>退出状态</h2>
<p>如果正常结束，那么 <span class="APPLICATION">psql</span> 向 shell 返回 0 ，如果自身发生致命错误，则返回 1(内存用尽，未找到文件等)，如果和数据库的连接失效而且会话不再活跃则返回 2 ，如果脚本中发生错误并且设置了 <tt class="VARNAME">ON_ERROR_STOP</tt> 则返回 3 。</p>
</div>
<div class="REFSECT1"><a name="AEN58467"></a><h2>用法</h2>
<div class="REFSECT2"><a name="R2-APP-PSQL-CONNECTING"></a><h3>连接一个数据库</h3>
<p><span class="APPLICATION">psql</span> 是一个普通的 PostgreSQL 客户端应用。为了与一个数据库连接，你需要知道目标数据库、服务器的主机名和端口号、以及你希望以哪个用户的身份进行连接等信息。可以通过命令行参数 <tt class="OPTION">-d</tt>, <tt class="OPTION">-h</tt>, <tt class="OPTION">-p</tt>, <tt class="OPTION">-U</tt> 告诉 <span class="APPLICATION">psql</span> 这些信息。如果某个参数不属于任何选项，那么它会被解释成数据库名或者是用户名(如果数据库名称已经给出了)。不是所有这些选项都是必须的，有的缺省就存在。如果你省略主机名，<span class="APPLICATION">psql</span> 将通过 Unix 域套接字与本地主机的服务器相联，或者在没有 unix 域套接字的机器上，通过 TCP/IP 与 <tt class="LITERAL">localhost</tt> 连接。缺省的端口号是编译时确定的。因为数据库服务器使用同样的缺省值，所以在大多数设置下，你可能不需要声明端口号。缺省的用户名是你的 Unix 用户名，与数据库同名。要注意的是你不能用任意用户名与任何数据库相联。你的数据库管理员应该告诉你有哪些访问权限。</p>
<p>如果缺省不太正确，那么你可以通过设置几个环境变量 <tt class="ENVAR">PGDATABASE</tt>, <tt class="ENVAR">PGHOST</tt>, <tt class="ENVAR">PGPORT</tt> and/or <tt class="ENVAR">PGUSER</tt> 的方法节约几次敲击。其它环境变量的信息，参阅<a href="libpq-envars.html">节29.12</a>。另外，用一个 <tt class="FILENAME">~/.pgpass</tt> 文件来避免输入密码也是很方便的。参阅<a href="libpq-pgpass.html">节29.13</a>获取更多信息。</p>
<p>如果因为任何原因而无法与数据库相联(权限不够、服务器没有运行等)，<span class="APPLICATION">psql</span> 将返回一个错误并退出。</p>
</div>
<div class="REFSECT2"><a name="R2-APP-PSQL-4"></a><h3>输入 SQL 命令</h3>
<p>通常状况下，<span class="APPLICATION">psql</span> 提供一个带有正在与之连接的接数据库名的，后缀 <tt class="LITERAL">=&gt;</tt> 的提示符。例如，</p>
<pre class="PROGRAMLISTING">$ <kbd class="USERINPUT">psql testdb</kbd>
Welcome to psql 8.2.3, the PostgreSQL interactive terminal.

Type:  \copyright for distribution terms
       \h for help with SQL commands
       \? for help with psql commands
       \g or terminate with semicolon to execute query
       \q to quit

testdb=&gt;</pre>
<p>用户可以在这个提示符下键入 SQL 命令。通常，输入的行将在命令终止分号出现时送到服务器。一行的终止并不表示命令的结束。因此命令可以为了清晰起见跨越好几行。如果命令发送出去而且执行没有错误，命令结果会显示在屏幕上。</p>
<p>当命令正在进行时，<span class="APPLICATION">psql</span> 同样还轮询由 <a href="sql-listen.html"><i>LISTEN</i></a> 和 <a href="sql-notify.html"><i>NOTIFY</i></a> 生成的异步通知信号。</p>
</div>
<div class="REFSECT2"><a name="AEN58505"></a><h3>元命令</h3>
<p>你在 <span class="APPLICATION">psql</span> 里输入的任何以不带引号的反斜杠开头的东西都是 <span class="APPLICATION">psql</span> 元命令，这些命令是将由 <span class="APPLICATION">psql</span> 自己处理的。这些命令也是使得 <span class="APPLICATION">psql</span> 更便于管理或书写脚本的原因。元命令更常见的叫法是斜杠或反斜杠命令。</p>
<p>一个 <span class="APPLICATION">psql</span> 命令的格式是反斜杠后面紧跟一个命令动词，然后是任意参数。参数与命令动词和其它参数以任意个空白字符间隔。</p>
<p>要在参数里面包含空白，你必须用单引号把它包围起来。要在这样的参数里包含单引号，可以在前面加一个反斜杠。任何包含在单引号里的东西都会被进一步进行类 C 的替换：<tt class="LITERAL">\n</tt> (新行)、<tt class="LITERAL">\t</tt> (制表符)、<tt class="LITERAL">\</tt><tt class="REPLACEABLE"><i>digits</i></tt> (八进制表示的字符)、<tt class="LITERAL">\x</tt><tt class="REPLACEABLE"><i>digits</i></tt> (十六进制表示的字符)</p>
<p>如果一个不带引号的参数以冒号(<tt class="LITERAL">:</tt>)开头，它会被当作一个 <span class="APPLICATION">psql</span> 变量，并且该变量的值会最终成为真正的参数值。</p>
<p>用反勾号(<tt class="LITERAL">`</tt>)包围的内容被当作一个命令行传入 shell 。该命令的输出(删除了结尾的新行)被当作参数值。上面描述的逃逸(字符)序列在反勾号里也生效。</p>
<p>有些命令以一个 SQL 标识的名称(比如一个表名)为参数。这些参数遵循 SQL 语法关于双引号的规则：不带双引号的标识强制成小写，而双引号保护字母不进行大小写转换，并且允许在标识符中使用空白。在双引号中，成对的双引号在结果名字中分析成一个双引号。比如，<tt class="LITERAL">FOO"BAR"BAZ</tt> 解析成 <tt class="LITERAL">fooBARbaz</tt> ；而 <tt class="LITERAL">"A weird"" name"</tt> 解析成 <tt class="LITERAL">A weird" name</tt></p>
<p>对参数的分析在碰到另一个不带引号的反斜杠时停止。这里会认为是一个新的元命令的开始。特殊的双反斜杠序列(<tt class="LITERAL">\\</tt>)标识参数的结尾并将继续分析后面的 SQL 命令(如果存在的话)。这样 SQL 和 <span class="APPLICATION">psql</span> 命令可以自由的在一行里面混合。但是在任何情况下，一条元命令的参数不能延续超过行尾。</p>
<p>下面是已定义的元命令：</p>
<div class="VARIABLELIST">
<dl>
<dt><tt class="LITERAL">\a</tt></dt>
<dd><p>如果目前的表输出格式是不对齐的，则切换成对齐的。如果是对齐的，则切换成不对齐。这条命令是为了向后兼容。参阅 <tt class="COMMAND">\pset</tt> 获取一个更通用的解决方法。</p></dd>
<dt><tt class="LITERAL">\cd [ <tt class="REPLACEABLE"><i>directory</i></tt> ]</tt></dt>
<dd><p>把当前工作目录改变到 <tt class="REPLACEABLE"><i>directory</i></tt> 。没有参数则是改变到当前用户的家目录。</p>
<div class="TIP">
<blockquote class="TIP">
<p><b>【提示】</b>使用 <tt class="LITERAL">\!pwd</tt> 打印出当前工作目录</p>
</blockquote>
</div></dd>
<dt><tt class="LITERAL">\C [ <tt class="REPLACEABLE"><i>title</i></tt> ]</tt></dt>
<dd><p>把正在打印的表的标题设置为一个查询的结果或者取消这样的设置。这条命令等效于 <tt class="LITERAL">\pset title <tt class="REPLACEABLE"><i>title</i></tt></tt> 。这条命令的名称源于"caption"，因为以前只是用于在一个 HTML 表格里面设置标题。</p></dd>
<dt><tt class="LITERAL">\connect</tt>(或 <tt class="LITERAL">\c</tt>) <tt class="LITERAL">[ <tt class="REPLACEABLE"><i>dbname</i></tt> [ <tt class="REPLACEABLE"><i>username</i></tt> ] [ <tt class="REPLACEABLE"><i>host</i></tt> ] [ <tt class="REPLACEABLE"><i>port</i></tt> ] ]</tt></dt>
<dd><p>与一个新的数据库建立一个连接，使用/不用一个用户名。前面的连接将关闭。如果 <tt class="REPLACEABLE"><i>dbname</i></tt>, <tt class="REPLACEABLE"><i>username</i></tt>, <tt class="REPLACEABLE"><i>host</i></tt>, <tt class="REPLACEABLE"><i>port</i></tt> 被省略或是 <tt class="LITERAL">-</tt> ，那么就使用上次连接里面的值。 如果之前没有链接则使用 <span class="APPLICATION">libpq</span> 的缺省值。</p>
<p>如果连接失败(用户名错、访问被拒绝等)，那么当 <span class="APPLICATION">psql</span> 处于交互模式时将保留前面的连接。如果运行的是非交互的脚本，处理会马上停止并返回一个错误。设置这样的区别一方面是为用户使用方便考虑，另一方面也为了保证脚本不会碰巧操作了错误的数据库的安全机制考虑。</p></dd>
<dt><tt class="LITERAL">\copy { <tt class="REPLACEABLE"><i>table</i></tt> [ ( <tt class="REPLACEABLE"><i>column_list</i></tt> ) ] | ( <tt class="REPLACEABLE"><i>query</i></tt> ) } { <tt class="LITERAL">from</tt> | <tt class="LITERAL">to</tt> } { <tt class="REPLACEABLE"><i>filename</i></tt> | stdin | stdout | pstdin | pstdout } [ with ] [ binary ] [ oids ] [ delimiter [ as ] '<tt class="REPLACEABLE"><i>character</i></tt>' ] [ null [ as ] '<tt class="REPLACEABLE"><i>string</i></tt>' ] [ csv [ header ] [ quote [ as ] '<tt class="REPLACEABLE"><i>character</i></tt>' ] [ escape [ as ] '<tt class="REPLACEABLE"><i>character</i></tt>' ] [ force quote <tt class="REPLACEABLE"><i>column_list</i></tt> ] [ force not null <tt class="REPLACEABLE"><i>column_list</i></tt> ] ]</tt></dt>
<dd><p>执行前端(客户端)拷贝。这是一个运行 SQL <a href="sql-copy.html"><i>COPY</i></a> 命令的操作，不同的是服务器在读写指明的文件，而 <span class="APPLICATION">psql</span> 读写文件并作为本地的文件系统和服务器之间的跳板取出或写入数据。这意味着文件访问性和权限都是本地用户的，而不是服务器的，因此不需要 SQL 超级用户权限。</p>
<p>这条命令的语法是模拟 SQL <a href="sql-copy.html"><i>COPY</i></a> 命令的。要注意的是因此带来一些应用于 <tt class="COMMAND">\copy</tt> 命令的特殊分析规则(尤其是变量替换规则和反斜杠代换规则)将不起作用。</p>
<p><tt class="LITERAL">\copy ... from stdin | to stdout</tt> 分别基于命令输入和输出进行读/写。所有行都从发出命令的同一个源读取，直到读到了 <tt class="LITERAL">\.</tt> 或者流达到 EOF 。输出发送到和命令输出相同的位置。要从 <span class="APPLICATION">psql</span> 的标准输入或者输出读/写，可以使用 <tt class="LITERAL">pstdin</tt> 或 <tt class="LITERAL">pstdout</tt> 。这个选项用于把和 SQL 脚本嵌在一起的文件填充表很有用。</p>
<div class="TIP">
<blockquote class="TIP">
<p><b>【提示】</b> 此操作不像 SQL <tt class="COMMAND">COPY</tt> 命令这样高效，因为所有数据必须通过客户端/服务器连接。对于大数据量的操作，SQL 命令的方法更可行。</p>
</blockquote>
</div></dd>
<dt><tt class="LITERAL">\copyright</tt></dt>
<dd><p>显示 PostgreSQL 的版权和版本信息。</p></dd>
<dt><tt class="LITERAL">\d [ <tt class="REPLACEABLE"><i>pattern</i></tt> ]</tt><br><tt class="LITERAL">\d+ [ <tt class="REPLACEABLE"><i>pattern</i></tt> ]</tt></dt>
<dd><p>对于每个匹配 <tt class="REPLACEABLE"><i>pattern</i></tt> 的关系(表、视图、索引、序列)，显示所有列、它们的类型、表空间(如果不是缺省的)和任何特殊属性(诸如 <tt class="LITERAL">NOT NULL</tt> 或缺省等，只要存在)。唯一约束相关的索引、规则、约束、触发器也同样显示出来。如果关系是一个视图，还显示视图的定义。"匹配模式"在下面定义。</p>
<p>从 <tt class="LITERAL">\d+</tt> 来的命令也是一样的，只不过显示更多信息：任何与表的列关联的注释也都会显示，还有就是表中出现的 OID 。</p>
<div class="NOTE">
<blockquote class="NOTE">
<p><b>【注意】</b>如果如果不带任何 <tt class="REPLACEABLE"><i>pattern</i></tt> 调用 <tt class="COMMAND">\d</tt> ，那么等效于 <tt class="COMMAND">\dtvs</tt> ，将显示一个所有表，视图和序列的列表。这完全是出于方便的考虑。</p>
</blockquote>
</div></dd>
<dt><tt class="LITERAL">\da [ <tt class="REPLACEABLE"><i>pattern</i></tt> ]</tt></dt>
<dd><p>列出所有可用的聚集函数，以及它们操作的数据类型。如果声明了 <tt class="REPLACEABLE"><i>pattern</i></tt> ，那么只显示匹配(正则表达式)的聚集函数。</p></dd>
<dt><tt class="LITERAL">\db [ <tt class="REPLACEABLE"><i>pattern</i></tt> ]</tt><br><tt class="LITERAL">\db+ [ <tt class="REPLACEABLE"><i>pattern</i></tt> ]</tt></dt>
<dd><p>列出所有可用的表空间。如果声明了 <tt class="REPLACEABLE"><i>pattern</i></tt> ，那么只显示那些匹配模式的表空间。如果在命令名上附加了 <tt class="LITERAL">+</tt> ，那么每个对象都和与之相关的权限一起列出。</p></dd>
<dt><tt class="LITERAL">\dc [ <tt class="REPLACEABLE"><i>pattern</i></tt> ]</tt></dt>
<dd><p>列出所有字符集之间的可用转换。如果声明了 <tt class="REPLACEABLE"><i>pattern</i></tt> ，则只列出那些匹配模式的转换。</p></dd>
<dt><tt class="LITERAL">\dC</tt></dt>
<dd><p>列出所有类型转换。</p></dd>
<dt><tt class="LITERAL">\dd [ <tt class="REPLACEABLE"><i>pattern</i></tt> ]</tt></dt>
<dd><p>显示所有匹配 <tt class="REPLACEABLE"><i>pattern</i></tt> 的描述，如果没有给出参数，显示所有可视对象。但是不管怎样，只有那些有描述内容的对象才显示出来。"对象"包括：聚集、函数、操作符、类型、关系(表、视图、索引、序列、大对象)、规则、触发器。例如：</p>
<pre class="PROGRAMLISTING">=&gt; <kbd class="USERINPUT">\dd version</kbd>
                     Object descriptions
   Schema   |  Name   |  Object  |        Description
------------+---------+----------+---------------------------
 pg_catalog | version | function | PostgreSQL version string
(1 row)</pre>
<p>可以用 <a href="sql-comment.html"><i>COMMENT</i></a> 命令生成对象的描述。</p></dd>
<dt><tt class="LITERAL">\dD [ <tt class="REPLACEABLE"><i>pattern</i></tt> ]</tt></dt>
<dd><p>列出所有可用域。如果声明了 <tt class="REPLACEABLE"><i>pattern</i></tt> ，那么只显示匹配的域。</p></dd>
<dt><tt class="LITERAL">\df [ <tt class="REPLACEABLE"><i>pattern</i></tt> ]</tt><br><tt class="LITERAL">\df+ [ <tt class="REPLACEABLE"><i>pattern</i></tt> ]</tt></dt>
<dd><p>列出所有可用函数，以及它们的参数和返回的数据类型。如果声明了 <tt class="REPLACEABLE"><i>pattern</i></tt> ，那么只显示匹配(正则表达式)的函数。如果使用了 <tt class="LITERAL">\df+</tt> 的形式，每个函数的附加信息，包括语言和描述也会显示出来。</p>
<div class="NOTE">
<blockquote class="NOTE">
<p><b>【注意】</b>要查找接受或者返回特定类型的函数，使用你的分页器搜索功能来滚动 <tt class="LITERAL">\df</tt> 的输出。</p>
<p>为了减少混乱，<tt class="LITERAL">\df</tt> 并不显示数据类型的输入输出函数。这样是通过忽略那些接受或者返回类型 <tt class="TYPE">cstring</tt> 的函数实现的。</p>
</blockquote>
</div></dd>
<dt><tt class="LITERAL">\dg [ <tt class="REPLACEABLE"><i>pattern</i></tt> ]</tt></dt>
<dd><p>列出所有数据库角色。如果声明了 <tt class="REPLACEABLE"><i>pattern</i></tt> ，那么只显示那些匹配模式的名字。这条命令实际上等于 <tt class="LITERAL">\du</tt></p></dd>
<dt><tt class="LITERAL">\distvS [ <tt class="REPLACEABLE"><i>pattern</i></tt> ]</tt></dt>
<dd><p>这不是实际的命令名称：字母 <tt class="LITERAL">i</tt>, <tt class="LITERAL">s</tt>, <tt class="LITERAL">t</tt>, <tt class="LITERAL">v</tt>, <tt class="LITERAL">S</tt> 分别代表索引(index)、序列(sequence)、表(table)、视图(view)、系统表(system table)。。你可以以任意顺序声明任意或者所有这些字母获得这些对象的一个列表。字母 <tt class="LITERAL">S</tt> 把列表限制于系统对象；如果没有 <tt class="LITERAL">S</tt> ，则只显示非系统对象。如果在命令名上附加了 <tt class="LITERAL">+</tt> ，那么还会列出和每个对象相关联的描述，如果有的话。</p>
<p>如果声明了 <tt class="REPLACEABLE"><i>pattern</i></tt> ，那么只列出匹配模式的对象。</p></dd>
<dt><tt class="LITERAL">\dl</tt></dt>
<dd><p><tt class="COMMAND">\lo_list</tt> 的别名，显示一个大对象的列表。</p></dd>
<dt><tt class="LITERAL">\dn [ <tt class="REPLACEABLE"><i>pattern</i></tt> ]</tt><br><tt class="LITERAL">\dn+ [ <tt class="REPLACEABLE"><i>pattern</i></tt> ]</tt></dt>
<dd><p>列出所有可用模式(名字空间)。如果声明了 <tt class="REPLACEABLE"><i>pattern</i></tt> ，那么只列出匹配模式的模式名。不显示非本地的临时模式。如果在命令名上附加了 <tt class="LITERAL">+</tt> ，那么每个对象都和与之相关的权限和注释一起列出(如果有的话)。</p></dd>
<dt><tt class="LITERAL">\do [ <tt class="REPLACEABLE"><i>pattern</i></tt> ]</tt></dt>
<dd><p>列出所有可用操作符，以及它们的操作数和返回的数据类型。如果声明了 <tt class="REPLACEABLE"><i>pattern</i></tt> ，那么只显示匹配模式的操作符。</p></dd>
<dt><tt class="LITERAL">\dp [ <tt class="REPLACEABLE"><i>pattern</i></tt> ]</tt></dt>
<dd><p>生成一列可用的表和它们相关的权限。如果声明了 <tt class="REPLACEABLE"><i>pattern</i></tt> ，那么只列出名字匹配模式的表。</p>
<p> <a href="sql-grant.html"><i>GRANT</i></a> 和 <a href="sql-revoke.html"><i>REVOKE</i></a> 命令用于设置访问权限。</p></dd>
<dt><tt class="LITERAL">\dT [ <tt class="REPLACEABLE"><i>pattern</i></tt> ]</tt><br><tt class="LITERAL">\dT+ [ <tt class="REPLACEABLE"><i>pattern</i></tt> ]</tt></dt>
<dd><p>列出所有数据类型或只显示那些匹配 <tt class="REPLACEABLE"><i>pattern</i></tt> 的。这条命令的 <tt class="LITERAL">\dT+</tt> 形式显示更多信息。</p></dd>
<dt><tt class="LITERAL">\du [ <tt class="REPLACEABLE"><i>pattern</i></tt> ]</tt></dt>
<dd><p>列出所有已配置角色或者只列出那些匹配 <tt class="REPLACEABLE"><i>pattern</i></tt> 的角色。</p></dd>
<dt><tt class="LITERAL">\edit</tt>(或 <tt class="LITERAL">\e</tt>) <tt class="LITERAL">[ <tt class="REPLACEABLE"><i>filename</i></tt> ]</tt></dt>
<dd><p>如果声明了 <tt class="REPLACEABLE"><i>filename</i></tt> ，则编辑此文件并且在编辑器退出后将其内容拷贝回查询缓冲区。如果没有给出此参数，则把当前查询缓冲区内容拷贝到一个临时文件然后以相同方式编辑。</p>
<p>然后根据一般的 <span class="APPLICATION">psql</span> 规则重新分析查询缓冲区，这时整个缓冲区当作一个单行，因此你无法用这个方法制作脚本(用 <tt class="COMMAND">\i</tt>)。这还意味着如果该查询以分号结尾(或者包含分号)，它就会马上被执行。否则它只是在查询缓冲区里等待。</p>
<div class="TIP">
<blockquote class="TIP">
<p><b>【提示】</b> <span class="APPLICATION">psql</span> 以 <tt class="ENVAR">PSQL_EDITOR</tt>, <tt class="ENVAR">EDITOR</tt>, <tt class="ENVAR">VISUAL</tt> 顺序搜索环境变量查找要用到哪个编辑器。如果上面的都没有设置，那么在 Unix 系统上使用 <tt class="FILENAME">vi</tt> ，而在 Windows 系统上用 <tt class="FILENAME">notepad.exe</tt> </p>
</blockquote>
</div></dd>
<dt><tt class="LITERAL">\echo <tt class="REPLACEABLE"><i>text</i></tt> [ ... ]</tt></dt>
<dd><p>向标准输出打印参数，用一个空格分隔并且最后跟着一个新行。这个特性在显示脚本的输出时会有用。例如：</p>
<pre class="PROGRAMLISTING">=&gt; <kbd class="USERINPUT">\echo `date`</kbd>
Tue Oct 26 21:40:57 CEST 1999</pre>
<p>如果第一个参数是一个无引号的 <tt class="LITERAL">-n</tt> ，那么不会写出结尾的新行。</p>
<div class="TIP">
<blockquote class="TIP">
<p><b>【提示】</b>如果使用 <tt class="COMMAND">\o</tt> 命令重定向查询的输出，你可能会用 <tt class="COMMAND">\qecho</tt> 取代这条命令。</p>
</blockquote>
</div></dd>
<dt><tt class="LITERAL">\encoding [ <tt class="REPLACEABLE"><i>encoding</i></tt> ]</tt></dt>
<dd><p>设置客户端字符编码方式。不带参数时，这条命令显示当前的编码方式。</p></dd>
<dt><tt class="LITERAL">\f [ <tt class="REPLACEABLE"><i>string</i></tt> ]</tt></dt>
<dd><p>为不对齐的查询输出设置域分隔符。缺省时是竖条(<tt class="LITERAL">|</tt>)。参阅 <tt class="COMMAND">\pset</tt> 获取设置输出选项的通用方法。</p></dd>
<dt><tt class="LITERAL">\g</tt> [ { <tt class="REPLACEABLE"><i>filename</i></tt> | <tt class="LITERAL">|</tt><tt class="REPLACEABLE"><i>command</i></tt> } ]</dt>
<dd><p>把当前的查询输入缓冲区的内容发送给服务器并且把查询的输出存储到可选的 <tt class="REPLACEABLE"><i>filename</i></tt> 或者把输出重定向到一个独立的执行 <tt class="REPLACEABLE"><i>command</i></tt> 的 Unix shell 。单独一个 <tt class="LITERAL">\g</tt> 实际上等效于一个分号。一个带有参数的 <tt class="LITERAL">\g</tt> 是"一次性"的 <tt class="COMMAND">\o</tt> 命令的代用品。</p></dd>
<dt><tt class="LITERAL">\help</tt>(或 <tt class="LITERAL">\h</tt>) <tt class="LITERAL">[ <tt class="REPLACEABLE"><i>command</i></tt> ]</tt></dt>
<dd><p>给出指定 SQL 命令的语法帮助。如果没有给出 <tt class="REPLACEABLE"><i>command</i></tt> ，那么 <span class="APPLICATION">psql</span> 将列出可获得语法帮助的所有命令。如果 <tt class="REPLACEABLE"><i>command</i></tt> 是一个星号(<tt class="LITERAL">*</tt>) ，则显示所有 SQL 命令的语法帮助。</p>
<div class="NOTE">
<blockquote class="NOTE">
<p><b>【注意】</b>为简化击键，包含多个单字的命令不需要引起。因此键入 <kbd class="USERINPUT">\help alter table</kbd> 是正确的。</p>
</blockquote>
</div></dd>
<dt><tt class="LITERAL">\H</tt></dt>
<dd><p>打开 HTML 查询输出格式。如果 HTML 格式已经打开，则切换回缺省的对齐的文本格式。这个命令是为了兼容和方便，参阅 <tt class="COMMAND">\pset</tt> 获取设置其它输出选项的内容。</p></dd>
<dt><tt class="LITERAL">\i <tt class="REPLACEABLE"><i>filename</i></tt></tt></dt>
<dd><p>从文件 <tt class="REPLACEABLE"><i>filename</i></tt> 中读取并把其内容当作从键盘输入的那样执行查询。</p>
<div class="NOTE">
<blockquote class="NOTE">
<p><b>【注意】</b>如果你想在屏幕上看到读入的行，就必须对所有行将变量 <tt class="VARNAME">ECHO</tt> 设置为 <tt class="LITERAL">all</tt></p>
</blockquote>
</div></dd>
<dt><tt class="LITERAL">\l</tt>(或 <tt class="LITERAL">\list</tt>)<br><tt class="LITERAL">\l+</tt>(或 <tt class="LITERAL">\list+</tt>)</dt>
<dd><p>列出服务器上所有数据库的名字和它们的所有者以及字符集编码。在命令名称后面加一个 <tt class="LITERAL">+</tt> 还可以看到对数据库的描述。</p></dd>
<dt><tt class="LITERAL">\lo_export <tt class="REPLACEABLE"><i>loid</i></tt> <tt class="REPLACEABLE"><i>filename</i></tt></tt></dt>
<dd><p>从数据库里读取 OID 为 <tt class="REPLACEABLE"><i>loid</i></tt> 的大对象并把它写到 <tt class="REPLACEABLE"><i>filename</i></tt> 里。注意这个功能与服务器函数 <code class="FUNCTION">lo_export</code> 有些微小的区别，后者运行时带着运行数据库服务器的用户权限，而且是在服务器的文件系统上。</p>
<div class="TIP">
<blockquote class="TIP">
<p><b>【提示】</b>使用 <tt class="COMMAND">\lo_list</tt> 查看大对象的 OID 。</p>
</blockquote>
</div></dd>
<dt><tt class="LITERAL">\lo_import <tt class="REPLACEABLE"><i>filename</i></tt> [ <tt class="REPLACEABLE"><i>comment</i></tt> ]</tt></dt>
<dd><p>把文件存储为一个 PostgreSQL 大对象。可以带着一个该对象的注解选项。例如：</p>
<pre class="PROGRAMLISTING">foo=&gt; <kbd class="USERINPUT">\lo_import '/home/peter/pictures/photo.xcf' 'a picture of me'</kbd>
lo_import 152801</pre>
<p>响应表明此大对象得到一个对象标识 152801 ，如果你还想访问该对象，就应该把这个对象标识记住。因此，建议总是给每个对象关联一个人类可读的注解。那样就可以用 <tt class="COMMAND">\lo_list</tt> 命令看到这些注解。</p>
<p>注意这条命令与服务器端的 <code class="FUNCTION">lo_import</code> 有一些区别，因为这条命令是本地用户在本地文件系统上操作，而不是以服务器用户在服务器文件系统上操作。</p></dd>
<dt><tt class="LITERAL">\lo_list</tt></dt>
<dd><p>显示一个目前存储在该数据库里的所有 PostgreSQL 大对象和它们的所有者的列表。</p></dd>
<dt><tt class="LITERAL">\lo_unlink <tt class="REPLACEABLE"><i>loid</i></tt></tt></dt>
<dd><p>从数据库里删除 OID 为 <tt class="REPLACEABLE"><i>loid</i></tt> 的大对象。</p>
<div class="TIP">
<blockquote class="TIP">
<p><b>【提示】</b>使用 <tt class="COMMAND">\lo_list</tt> 查找大对象的 OID 。</p>
</blockquote>
</div></dd>
<dt><tt class="LITERAL">\o</tt> [ {<tt class="REPLACEABLE"><i>filename</i></tt> | <tt class="LITERAL">|</tt><tt class="REPLACEABLE"><i>command</i></tt>} ]</dt>
<dd><p>把后面的查询结果保存到文件 <tt class="REPLACEABLE"><i>filename</i></tt> 里或者把后面的查询结果重定向到一个独立执行 <tt class="REPLACEABLE"><i>command</i></tt> 的 Unix shell 。如果没有声明参数，查询输出将被重置为标准输出。</p>
<p>"查询结果"包括所有表，命令响应和从数据库服务器来的提示，同样还有各种各样查询数据库的反斜杠命令的输出(如 <tt class="COMMAND">\d</tt>)，但是没有错误信息。</p>
<div class="TIP">
<blockquote class="TIP">
<p><b>【提示】</b>要用文本分散查询结果之间的输出，用 <tt class="COMMAND">\qecho</tt></p>
</blockquote>
</div></dd>
<dt><tt class="LITERAL">\p</tt></dt>
<dd><p>打印当前查询缓冲区到标准输出。</p></dd>
<dt><tt class="LITERAL">\password [ <tt class="REPLACEABLE"><i>username</i></tt> ]</tt></dt>
<dd><p>更改指定用户的口令，缺省为当前用户。该命令将提示口令输入，然后将加密过的口令使用 <tt class="COMMAND">ALTER ROLE</tt> 之类的命令发送给服务器。这可以保证新口令不会以明文形式出现在命令历史、服务器日志、或其他什么地方。</p></dd>
<dt><tt class="LITERAL">\pset <tt class="REPLACEABLE"><i>parameter</i></tt> [ <tt class="REPLACEABLE"><i>value</i></tt> ]</tt></dt>
<dd><p>这条命令设置影响查询结果表输出的选项。<tt class="REPLACEABLE"><i>parameter</i></tt> 描述要设置的选项是哪一个。<tt class="REPLACEABLE"><i>value</i></tt> 的语意也取决于它。</p>
<p>可调节的打印选项有：</p>
<div class="VARIABLELIST">
<dl>
<dt><tt class="LITERAL">format</tt></dt>
<dd><p>设置输出格式为 <tt class="LITERAL">unaligned</tt>, <tt class="LITERAL">aligned</tt>, <tt class="LITERAL">html</tt>, <tt class="LITERAL">latex</tt>, <tt class="LITERAL">troff-ms</tt> 之一。允许使用唯一缩写，这也意味着一个字母就够了。</p>
<p>"Unaligned"(不对齐)把一条记录的所有字段都输出到一行，用当前有效的域分隔符分隔。这主要用于生成那些要被其它程序读取的输出(制表符分隔、逗号分隔)。"Aligned"(对齐)模式是标准的，人类可读的，格式化好了的文本输出，也是缺省。"HTML"和"LaTeX"模式把表输出为可用于文档里的对应标记语言。它们还不是完整的文档！可能对于 HTML 变化还不是太大，但是在 LaTeX 里，你必须有一个完整的文档包装器。</p></dd>
<dt><tt class="LITERAL">border</tt></dt>
<dd><p>第二个参数必须是一个数字。通常，数字越大，表就有越宽的边界和越多的线，但是这个参数取决于实际的格式。在 HTML 模式里，这个参数会直接翻译成 <tt class="LITERAL">border=...</tt> 属性，在其它的模式里，只有值 0(无边界)、1(内部分隔线)、2(表框架)有意义。</p></dd>
<dt><tt class="LITERAL">expanded</tt>(或 <tt class="LITERAL">x</tt>)</dt>
<dd><p>在正常和扩展格式之间切换。当打开扩展格式时，查询结果用两列显示，字段名称在左、数据在右。这个模式在数据无法放进通常的"水平"模式的屏幕时很有用。</p>
<p>所有四种输出模式都支持扩展格式。</p></dd>
<dt><tt class="LITERAL">null</tt></dt>
<dd><p>第二个参数是一个字符串，用以代表字段的值为 null 时的打印输出。缺省是什么都不打，这样很容易和类似一个空字符串混淆。因此，可能选择 <tt class="LITERAL">\pset null '(null)'</tt></p></dd>
<dt><tt class="LITERAL">fieldsep</tt></dt>
<dd><p>声明在非对齐模式时的域分隔符。这样就可以创建其它程序希望的制表符或逗号分隔的输出。要设置制表符域分隔符，键入 <tt class="LITERAL">\pset fieldsep '\t'</tt> 。缺省域分隔符是 <tt class="LITERAL">'|'</tt> (竖条符)。</p></dd>
<dt><tt class="LITERAL">footer</tt></dt>
<dd><p>切换缺省脚注<tt class="LITERAL">(x rows)</tt></p></dd>
<dt><tt class="LITERAL">numericlocale</tt></dt>
<dd><p>切换分隔小数点左边的数值的区域相关的分组符号。它还打开区域相关的小数点。</p></dd>
<dt><tt class="LITERAL">recordsep</tt></dt>
<dd><p>声明在非对齐模式时的记录分隔符。缺省是换行符。</p></dd>
<dt><tt class="LITERAL">tuples_only</tt>(或 <tt class="LITERAL">t</tt>)</dt>
<dd><p>在完全显示和只显示记录之间切换。完全显示将显示像列头、标题、各种脚注等信息。在这个模式下，只显示记录模式将只显示实际的表数据。</p></dd>
<dt><tt class="LITERAL">title [ <tt class="REPLACEABLE"><i>text</i></tt> ]</tt></dt>
<dd><p>为任何随后打印的表设置标题。这个参数可以用于给你的输出一个描述性标记。如果不带参数，重置标题。</p></dd>
<dt><tt class="LITERAL">tableattr</tt>(或 <tt class="LITERAL">T</tt>) <tt class="LITERAL">[ <tt class="REPLACEABLE"><i>text</i></tt> ]</tt></dt>
<dd><p>允许你声明放在 HTML <code class="SGMLTAG">table</code> 标签里的任何属性(例如 <tt class="LITERAL">cellpadding</tt> 或 <tt class="LITERAL">bgcolor</tt>)。注意，你可能不需要在这里声明 <tt class="LITERAL">border</tt> ，因为已经在 <tt class="LITERAL">\pset border</tt> 里用过了。</p></dd>
<dt><tt class="LITERAL">pager</tt></dt>
<dd><p>控制查询和 <span class="APPLICATION">psql</span> 帮助输出的分页器。如果设置了环境变量 <tt class="ENVAR">PAGER</tt> ，那么输出被定向到指定程序，否则使用系统缺省(比如 <tt class="FILENAME">more</tt>)。</p>
<p>如果关闭了分页器，则不使用它，如果打开了，程序只在需要的时候使用分页器，也就是说，输出是到终端，而且那个表很可能无法与屏幕匹配。<span class="APPLICATION">psql</span> 在决定何时分页时不是很完美。<tt class="LITERAL">\pset pager</tt> 开关分页器。也可以把分页器设置为 <tt class="LITERAL">always</tt> ，导致在任何情况下都使用分页器。</p></dd>
</dl>
</div>
<p>可以在<a href="app-psql.html#APP-PSQL-EXAMPLES"><i>例子</i></a>小节看到这些不同格式输出的示例。</p>
<div class="TIP">
<blockquote class="TIP">
<p><b>【提示】</b>有很多用于 <tt class="COMMAND">\pset</tt> 的快速命令。参阅 <tt class="COMMAND">\a</tt>, <tt class="COMMAND">\C</tt>, <tt class="COMMAND">\H</tt>, <tt class="COMMAND">\t</tt>, <tt class="COMMAND">\T</tt>, <tt class="COMMAND">\x</tt></p>
</blockquote>
</div>
<div class="NOTE">
<blockquote class="NOTE">
<p><b>【注意】</b>无参数运行 <tt class="COMMAND">\pset</tt> 是错误的。以后这样调用将显示当前打印选项状态。</p>
</blockquote>
</div></dd>
<dt><tt class="LITERAL">\q</tt></dt>
<dd><p>退出 <span class="APPLICATION">psql</span> 程序。</p></dd>
<dt><tt class="LITERAL">\qecho <tt class="REPLACEABLE"><i>text</i></tt> [ ... ] </tt></dt>
<dd><p>这条命令等效于 <tt class="COMMAND">\echo</tt> ，区别是所有输出将写入由 <tt class="COMMAND">\o</tt> 设置的输出通道。</p></dd>
<dt><tt class="LITERAL">\r</tt></dt>
<dd><p>重置(清空)查询缓冲区</p></dd>
<dt><tt class="LITERAL">\s [ <tt class="REPLACEABLE"><i>filename</i></tt> ]</tt></dt>
<dd><p>将命令行历史打印出或是存放到 <tt class="REPLACEABLE"><i>filename</i></tt> 。如果省略则输出到标准输出。这个选项只有在 <span class="APPLICATION">psql</span> 配置成使用 GNU <span class="APPLICATION">Readline</span> 库后才生效。</p></dd>
<dt><tt class="LITERAL">\set [ <tt class="REPLACEABLE"><i>name</i></tt> [ <tt class="REPLACEABLE"><i>value</i></tt> [ ... ] ] ]</tt></dt>
<dd><p>设置内部变量 <tt class="REPLACEABLE"><i>name</i></tt> 为 <tt class="REPLACEABLE"><i>value</i></tt> 或者如果给出了多于一个值，设置为所有这些值的连接结果。如果没有给出第二个参数，那么只设变量不设值。要重置一个变量，使用 <tt class="COMMAND">\unset</tt> 命令。</p>
<p>有效的变量名可以包含字符，数字和下划线。参阅下面的<a href="app-psql.html#APP-PSQL-VARIABLES"><i>变量</i></a>获取细节。</p>
<p>尽管你可以设置任何变量为任意值，<span class="APPLICATION">psql</span> 对一些变量特殊对待。它们在关于变量的小节里面有文档。</p>
<div class="NOTE">
<blockquote class="NOTE">
<p><b>【注意】</b>这条命令和 SQL 命令 <a href="sql-set.html"><i>SET</i></a> 是完全不一样的。</p>
</blockquote>
</div></dd>
<dt><tt class="LITERAL">\t</tt></dt>
<dd><p>切换输出的字段名的信息头和行记数脚注。这条命令等效于 <tt class="LITERAL">\pset tuples_only</tt> ，提供它主要为了方便。</p></dd>
<dt><tt class="LITERAL">\T <tt class="REPLACEABLE"><i>table_options</i></tt></tt></dt>
<dd><p>允许你在使用 HTML 输出模式时声明放在 <code class="SGMLTAG">table</code> 标记里的属性。这条命令等效于 <tt class="LITERAL">\pset tableattr <tt class="REPLACEABLE"><i>table_options</i></tt></tt></p></dd>
<dt><tt class="LITERAL">\timing</tt></dt>
<dd><p>以毫秒为单位显示每条 SQL 语句的耗时。</p></dd>
<dt><tt class="LITERAL">\w</tt> {<tt class="REPLACEABLE"><i>filename</i></tt> | <tt class="REPLACEABLE"><i>|command</i></tt>}</dt>
<dd><p>将当前查询缓冲区输出到文件 <tt class="REPLACEABLE"><i>filename</i></tt> 或者重定向到 Unix 命令 <tt class="REPLACEABLE"><i>command</i></tt></p></dd>
<dt><tt class="LITERAL">\x</tt></dt>
<dd><p>切换扩展行格式。等效于 <tt class="LITERAL">\pset expanded</tt></p></dd>
<dt><tt class="LITERAL">\z [ <tt class="REPLACEABLE"><i>pattern</i></tt> ]</tt></dt>
<dd><p>生成一个带有访问权限列表的数据库中所有表、视图、序列的列表。如果给出任何 <tt class="REPLACEABLE"><i>pattern</i></tt> ，则被当成一个正则表达式，只显示匹配的表、视图、序列。</p>
<p><a href="sql-grant.html"><i>GRANT</i></a> 和 <a href="sql-revoke.html"><i>REVOKE</i></a> 命令用于设置访问权限。</p>
<p>这是 <tt class="COMMAND">\dp</tt> (显示权限)的别名。</p></dd>
<dt><tt class="LITERAL">\! [ <tt class="REPLACEABLE"><i>command</i></tt> ]</tt></dt>
<dd><p>返回到一个单独的 Unix shell 或者执行 Unix 命令 <tt class="REPLACEABLE"><i>command</i></tt> 。参数不会被进一步解释，shell 将看到全部参数。</p></dd>
<dt><tt class="LITERAL">\?</tt></dt>
<dd><p>获得关于反斜杠命令的帮助信息。</p></dd>
</dl>
</div>
<div class="REFSECT3"><a name="APP-PSQL-PATTERNS"></a><h4>匹配模式</h4><a name="AEN59207"></a>
<p>各种 <tt class="LITERAL">\d</tt> 命令都接受一个 <tt class="REPLACEABLE"><i>pattern</i></tt> 参数，声明要显示的对象名字。最简单的情况下 pattern 正好等于对象的名字。pattern 中的字符通常会被自动转换成小写，就像 SQL 名字一样。例如 <tt class="LITERAL">\dt FOO</tt> 将显示名为 <tt class="LITERAL">foo</tt> 的表。与在 SQL 名字中相同的是双引号界定的 pattern 将保持原样(不做大小写转换)。如果需要在双引号界定的 pattern 中使用双引号字符，你可以写两个并列的双引号，这与 SQL 的引号规则相同。例如，<tt class="LITERAL">\dt "FOO""BAR"</tt> 将会显示名为 <tt class="LITERAL">FOO"BAR</tt> 的表，但是不会显示 <tt class="LITERAL">foo"bar</tt> 。与一般的 SQL 名字规则不同的是，你可以仅用双引号界定名字的一部分，例如 <tt class="LITERAL">\dt FOO"FOO"BAR</tt> 将显示名为 <tt class="LITERAL">fooFOObar</tt> 的表。</p>
<p>pattern 中的 <tt class="LITERAL">*</tt> 表示"任何字符序列"，包括"没有字符"，而 <tt class="LITERAL">?</tt> 表示"任何单个字符"。这个表示法和 Unix 的 shell 文件名模式兼容。比如 <tt class="LITERAL">\dt int*</tt> 显示所有名字以 <tt class="LITERAL">int</tt> 开头的表。但是在双引号内部的 <tt class="LITERAL">*</tt> 和 <tt class="LITERAL">?</tt> 不具有匹配的功能，它们只代表自身。</p>
<p>包含点(<tt class="LITERAL">.</tt>)的 pattern 将被解释成模式名 pattern 后面跟一个对象名 pattern 。例如 <tt class="LITERAL">\dt foo*.bar*</tt> 显示所有名字以 <tt class="LITERAL">foo</tt> 开头的模式中的所有名字以 <tt class="LITERAL">bar</tt> 开头的表。如果没有出现句点，那么这个模式只匹配在当前模式搜索路径中可见的对象。同样，在双引号内的点没有这个含义，它只代表其自身。</p>
<p>还可以使用正则表达式语法，比如字符类等等。例如用 <tt class="LITERAL">[0-9]</tt> 匹配所有数字。除 <tt class="LITERAL">.</tt> 之外的所有正则表达式中的特殊字符都按照<a href="functions-matching.html#FUNCTIONS-POSIX-REGEXP">节9.7.3</a>里面描述的规则进行解析，此外，<tt class="LITERAL">*</tt> 将被理解成 <tt class="LITERAL">.*</tt> ，同时 <tt class="LITERAL">?</tt> 将被理解成 <tt class="LITERAL">.</tt> 。这样一来，你就可以用 <tt class="LITERAL">?</tt> 代替 <tt class="LITERAL">.</tt> 、用 <tt class="LITERAL">(<tt class="REPLACEABLE"><i>R</i></tt>+|)</tt> for <tt class="LITERAL"><tt class="REPLACEABLE"><i>R</i></tt>*</tt> 、用 <tt class="LITERAL">(<tt class="REPLACEABLE"><i>R</i></tt>|)</tt> 代替 <tt class="LITERAL"><tt class="REPLACEABLE"><i>R</i></tt>?</tt> 。需要注意的是模式必须匹配整个名称，而不是一般理解的匹配一部分即可。如果你只想匹配一部分，可以在 pattern 的开头和结尾使用 <tt class="LITERAL">*</tt> 。还需要注意的是在双引号内部的所有正则表达式特殊字符都将失去其特殊含义。同样，在对操作符(也就是作为 <tt class="LITERAL">\do</tt> 参数的时候)进行匹配时正则表达式特殊字符也将失去其特殊含义。</p>
<p>如果完全省略 <tt class="REPLACEABLE"><i>pattern</i></tt> 参数，那么 <tt class="LITERAL">\d</tt> 命令显示所有在当前模式搜索路径中可见的对象(等价于使用 <tt class="LITERAL">*</tt> 匹配模式)。要查阅在数据库中的所有对象，使用 <tt class="LITERAL">*.*</tt> 模式。</p>
</div>
</div>
<div class="REFSECT2"><a name="AEN59257"></a><h3>高级特性</h3>
<div class="REFSECT3"><a name="APP-PSQL-VARIABLES"></a><h4>变量</h4>
<p><span class="APPLICATION">psql</span> 提供类似通常 Unix 命令 shell 那样的变量替换特性。变量只是简单的名称/值对，这里的值可以是任何长度的任何值。可以使用 <span class="APPLICATION">psql</span> 元命令 <tt class="COMMAND">\set</tt> 设置一个变量：</p>
<pre class="PROGRAMLISTING">testdb=&gt; <kbd class="USERINPUT">\set foo bar</kbd></pre>
<p>把变量 <tt class="LITERAL">foo</tt> 的值设置为 <tt class="LITERAL">bar</tt> 。要检索变量的内容，在变量名前面放上冒号然后把它用在任意斜杠命令里：</p>
<pre class="PROGRAMLISTING">testdb=&gt; <kbd class="USERINPUT">\echo :foo</kbd>
bar</pre>
<div class="NOTE">
<blockquote class="NOTE">
<p><b>【注意】</b><tt class="COMMAND">\set</tt> 的参数服从和其它命令一样的替换规则。因此你可以构造有趣的引用，像 <tt class="LITERAL">\set :foo 'something'</tt> 这样，获得分别像 Perl 或 PHP 那样有名的"软连接"或"变量变量"。不幸(或者万幸?)的是，用这些构造不能做任何有用的事情。另一方面，<tt class="LITERAL">\set bar :foo</tt> 是一个非常有效的拷贝变量的方法。</p>
</blockquote>
</div>
<p>如果你不带第二个参数调用 <tt class="COMMAND">\set</tt> ，那么只是设置这个变量而没有值。要重置(或删除)一个变量，使用 <tt class="COMMAND">\unset</tt> 命令。</p>
<p><span class="APPLICATION">psql</span> 的内部变量可以包括任意顺序和数量的字母、数字、下划线。有一些常用变量被 <span class="APPLICATION">psql</span> 特殊相待。它们是一些选项设置，，这些选项在运行时可以通过改变变量的值或者改变一些应用的表现状态而改变。尽管你可以把这些变量用于其它用途，但是不鼓励这么做，因为程序的特性可能会变得非常奇怪。通常，所有特殊对待的变量都是由大写字母组成(可能还有数字和下划线)。为了保证和未来的最大限度的兼容性，请避免使用这样的变量。下面是一个所有特殊对待的变量列表。</p>
<div class="VARIABLELIST">
<dl>
<dt><tt class="VARNAME">AUTOCOMMIT</tt></dt>
<dd><p>如果是 <tt class="LITERAL">on</tt>(缺省)，那么每个 SQL 命令都在成功完成后自动提交。要推迟这种模式下的提交，你必须输入一个 <tt class="COMMAND">BEGIN</tt> 或 <tt class="COMMAND">START TRANSACTION</tt> 命令。如果是 <tt class="LITERAL">off</tt> 或者未设置，SQL 命令不会提交，直到你明确地发出 <tt class="COMMAND">COMMIT</tt> 或 <tt class="COMMAND">END</tt> 。关闭自动提交的模式是通过为你明确发出一个 <tt class="COMMAND">BEGIN</tt> 实现的，它是放在任何尚未在一个事务块中并且自己不是 <tt class="COMMAND">BEGIN</tt> 或其它事务控制命令也不是那些不能在事务块里执行的命令(比如 <tt class="COMMAND">VACUUM</tt>)的前面。</p>
<div class="NOTE">
<blockquote class="NOTE">
<p><b>【注意】</b>在关闭自动提交的模式下，你必须明确放弃任何失败的事务，方法是执行 <tt class="COMMAND">ABORT</tt> 或 <tt class="COMMAND">ROLLBACK</tt> 。还要注意，如果你不提交就退出会话，所做的工作会丢失。</p>
</blockquote>
</div>
<div class="NOTE">
<blockquote class="NOTE">
<p><b>【注意】</b>打开自动提交是 PostgreSQL 的传统行为，但是关闭自动提交更接近 SQL 规范。你可以在系统范围的 <tt class="FILENAME">psqlrc</tt> 或 <tt class="FILENAME">~/.psqlrc</tt> 文件中关闭自动提交。</p>
</blockquote>
</div></dd>
<dt><tt class="VARNAME">DBNAME</tt></dt>
<dd><p>正在连接着的数据库名称。每次与一个数据库联结都会设置这个值(包括程序启动)，但是可以删除。</p></dd>
<dt><tt class="VARNAME">ECHO</tt></dt>
<dd><p>如果设为 <tt class="LITERAL">all</tt> ，那么来自键盘或脚本的所有输入行在分析或执行前都回显到标准输出。使用 <tt class="OPTION">-a</tt> 选项声明在程序启动时就默认这样做。如果设置为 <tt class="LITERAL">queries</tt> ，那么 <span class="APPLICATION">psql</span> 只是在查询发送给服务器之前打印出来。实现这个功能的命令行选项是 <tt class="OPTION">-e</tt></p></dd>
<dt><tt class="VARNAME">ECHO_HIDDEN</tt></dt>
<dd><p>当设置了这个变量并且一个反斜杠命令查询数据库时，首先显示查询。这样你可以学习 PostgreSQL 内部的东西并且在你自己的程序里提供类似功能。要在程序一起动的时候就启用这个行为，可以使用 <tt class="OPTION">-E</tt> 选项。如果你设置该变量的值为 <tt class="LITERAL">noexec</tt> ，那么查询只是显示出来但是实际上不发送到服务器去执行。</p></dd>
<dt><tt class="VARNAME">ENCODING</tt></dt>
<dd><p>当前的客户端字符集编码</p></dd>
<dt><tt class="VARNAME">FETCH_COUNT</tt></dt>
<dd><p>如果该变量的值大于零，<tt class="COMMAND">SELECT</tt> 查询的结果将按此值分批返回和显示，而不是缺省的一次取出和显示所有结果。这样就可以无论结果集有多大都只使用很少量的内存。一般来说，设为 100 到 1000 之间的值比较合理。需要注意的是，使用此特性后，一个查询可能在显示了一部分结果之后遭遇失败。</p>
<div class="TIP">
<blockquote class="TIP">
<p><b>【提示】</b>虽然该特性可以用于所有输出格式。但是并不适合在缺省的 <tt class="LITERAL">aligned</tt> 格式上使用这个特性，因为每一批结果会被单独的分开格式化，这样一来每一批输出结果的列宽就可能各不相等。不过对于其他格式这个特性工作的很好。</p>
</blockquote>
</div></dd>
<dt><tt class="VARNAME">HISTCONTROL</tt></dt>
<dd><p>如果将这个变量设为 <tt class="LITERAL">ignorespace</tt> ，那么以空格开始的行将不会进入历史列表。如果设置为 <tt class="LITERAL">ignoredups</tt> ，那么与以前历史记录里匹配的行也不会进入历史记录。值 <tt class="LITERAL">ignoreboth</tt> 是上面两个的结合。如果删除此变量或者其值为任何与上面的值不同的东西，所有交互模式读入的行都被保存入历史列表。</p>
<div class="NOTE">
<blockquote class="NOTE">
<p><b>【注意】</b>这个特性是从 <span class="APPLICATION">Bash</span> 偷学来的。</p>
</blockquote>
</div></dd>
<dt><tt class="VARNAME">HISTFILE</tt></dt>
<dd><p>此文件将用于存储历史列表。缺省值是 <tt class="FILENAME">~/.psql_history</tt> 。比如，在 <tt class="FILENAME">~/.psqlrc</tt> 里使用：</p>
<pre class="PROGRAMLISTING">\set HISTFILE ~/.psql_history- :DBNAME</pre>
<p>将使得 <span class="APPLICATION">psql</span> 为每个数据库维护一个独立的历史。</p>
<div class="NOTE">
<blockquote class="NOTE">
<p><b>【注意】</b>这个特性是从 <span class="APPLICATION">Bash</span> 偷学来的。</p>
</blockquote>
</div></dd>
<dt><tt class="VARNAME">HISTSIZE</tt></dt>
<dd><p>保存在命令历史里的命令的个数。缺省值是 500 。</p>
<div class="NOTE">
<blockquote class="NOTE">
<p><b>【注意】</b>这个特性是从 <span class="APPLICATION">Bash</span> 偷学来的。</p>
</blockquote>
</div></dd>
<dt><tt class="VARNAME">HOST</tt></dt>
<dd><p>当前你正连接的数据库服务器主机。这是在每次你与数据库连接时(包括程序启动)设置的，但是可以删除。</p></dd>
<dt><tt class="VARNAME">IGNOREEOF</tt></dt>
<dd><p>如果删除此变量，向一个交互的 <span class="APPLICATION">psql</span> 会话发送一个 EOF(通常是 <b class="KEYCAP">Control</b>+<b class="KEYCAP">D</b>)将终止应用。如果设置为一个数字值，那么在应用终止前该数值的 EOF 字符将被忽略。如果设置了此变量但是没有数字值，缺省是 10 。</p>
<div class="NOTE">
<blockquote class="NOTE">
<p><b>【注意】</b>这个特性是从 <span class="APPLICATION">Bash</span> 偷学来的。</p>
</blockquote>
</div></dd>
<dt><tt class="VARNAME">LASTOID</tt></dt>
<dd><p>最后影响的 oid 值，即为从一条 <tt class="COMMAND">INSERT</tt> 或 <tt class="COMMAND">lo_insert</tt> 命令返回的值。此变量只保证在下一条 SQL 命令的结果显示之前有效。</p></dd>
<dt><tt class="VARNAME">ON_ERROR_ROLLBACK</tt></dt>
<dd><p>如果是 <tt class="LITERAL">on</tt> ，那么当一个事务块里的语句产生错误的时候，这个错误将被忽略而事务将继续。如果是 <tt class="LITERAL">interactive</tt> ，那么这样的错误只是在交互的会话里忽略，而不是在从读取脚本文件的时候。如果是 <tt class="LITERAL">off</tt>(缺省)，事务块里一个语句生成的错误将会回滚整个事务。on_error_rollback-on 的模式是通过在一个事务块的每个命令前为你隐含地发出一个 <tt class="COMMAND">SAVEPOINT</tt> 的方式工作的，在发生错误的时候回滚到该事务块。</p></dd>
<dt><tt class="VARNAME">ON_ERROR_STOP</tt></dt>
<dd><p>缺省时，如果非交互的脚本碰到一个错误(比如一条错误的 SQL 命令或者内部元命令)，处理会继续进行。这是 <span class="APPLICATION">psql</span> 的传统特性，但是有时候不太希望这样。如果设置了这个变量，脚本处理将马上停止。如果该脚本是从另外一个脚本调用的，那个脚本也会按同样的方式停止。如果最外层的脚本不是从一次交互的 <span class="APPLICATION">psql</span> 会话中调用的而是用 <tt class="OPTION">-f</tt> 选项调用的，<span class="APPLICATION">psql</span> 将返回错误代码 3 ，以示这个情况与致命错误条件的区别(错误代码为 1)。</p></dd>
<dt><tt class="VARNAME">PORT</tt></dt>
<dd><p>当前你正在连接的数据库服务器的端口。这是在每次你与数据库连接时(包括程序启动)设置的，但是可以删除。</p></dd>
<dt><tt class="VARNAME">PROMPT1</tt><br><tt class="VARNAME">PROMPT2</tt><br><tt class="VARNAME">PROMPT3</tt></dt>
<dd><p>这些指明 <span class="APPLICATION">psql</span> 显示的提示符看上去像什么。参阅下面的<a href="app-psql.html#APP-PSQL-PROMPTING"><i>提示符</i></a>。</p></dd>
<dt><tt class="VARNAME">QUIET</tt></dt>
<dd><p>这个变量等效于命令行选项 <tt class="OPTION">-q</tt> 。可能在交互模式下没有什么用。</p></dd>
<dt><tt class="VARNAME">SINGLELINE</tt></dt>
<dd><p>这个变量等效于命令行选项 <tt class="OPTION">-S</tt></p></dd>
<dt><tt class="VARNAME">SINGLESTEP</tt></dt>
<dd><p>这个变量等效于命令行选项 <tt class="OPTION">-s</tt></p></dd>
<dt><tt class="VARNAME">USER</tt></dt>
<dd><p>当前你正用于连接的数据库用户。这是在每次你与数据库连接时(包括程序启动)设置的，但是可以被删除。</p></dd>
<dt><tt class="VARNAME">VERBOSITY</tt></dt>
<dd><p>这个选项可以设置为值 <tt class="LITERAL">default</tt>, <tt class="LITERAL">verbose</tt>, <tt class="LITERAL">terse</tt> 之一以控制错误报告的冗余行。</p></dd>
</dl>
</div>
</div>
<div class="REFSECT3"><a name="AEN59479"></a><h4>SQL 代换</h4>
<p>一个附加的 <span class="APPLICATION">psql</span> 变量的有用特性是你可以把它们替换成正规的 SQL 语句。这样做的语法同样还是变量名前面加一个冒号(<tt class="LITERAL">:</tt>)。</p>
<pre class="PROGRAMLISTING">testdb=&gt; <kbd class="USERINPUT">\set foo 'my_table'</kbd>
testdb=&gt; <kbd class="USERINPUT">SELECT * FROM :foo;</kbd></pre>
<p>将会查询 <tt class="LITERAL">my_table</tt> 表。变量的值是逐字拷贝的，所以它甚至可以包含不对称的引号或反斜杠命令。你必须保证你输入的东西是有意义的。变量替换将不会在引号界定的 SQL 语句里面发生。</p>
<p>利用这个功能的一个时髦的应用是通过使用一个随后的语句中最后插入的 OID 建立一个外键仿真场景。另一个可能用到这个机制的地方是把一个文件的内容拷贝到一个字段里面去。首先把文件加载到一个变量然后像上面那样处理。</p>
<pre class="PROGRAMLISTING">testdb=&gt; <kbd class="USERINPUT">\set content '''' `cat my_file.txt` ''''</kbd>
testdb=&gt; <kbd class="USERINPUT">INSERT INTO my_table VALUES (:content);</kbd></pre>
<p>这样处理的一个可能问题是 <tt class="FILENAME">my_file.txt</tt> 可能包含单引号。这些需要被逃逸以免在处理第三行时不会导致语法错误。可以使用程序 <tt class="COMMAND">sed</tt> 来做这个处理：</p>
<pre class="PROGRAMLISTING">testdb=&gt; <kbd class="USERINPUT">\set content '''' `sed -e "s/'/''/g" &lt; my_file.txt` ''''</kbd></pre>
<p>如果使用非标准兼容的字符串，那么仍然需要双写反斜杠。这有些麻烦：</p>
<pre class="PROGRAMLISTING">testdb=&gt; <kbd class="USERINPUT">\set content '''' `sed -e "s/'/''/g" -e 's/\\/\\\\/g' &lt; my_file.txt` ''''</kbd></pre>
<p>请注意不同的 shell 引号风格的使用，单引号和反斜杠对于 shell 来说都不是特殊字符。但是反斜杠对于 <tt class="COMMAND">sed</tt> 是特殊字符，因此需要双写。所有的 Unix 命令都使用相同的逃逸字符，这一点真是太爽了。</p>
<p>因为冒号也可以合法的出现在 SQL 命令里，便有下面的规则：除非"name"是当前设置的某个变量的名字，否则字符序列":name"不会变化。但是无论如何，你都可以用反斜杠逃逸冒号以防止它被替换。变量的冒号语法符合诸如 <span class="APPLICATION">ECPG</span> 之类的嵌入式 SQL 标准。用于数组片段和类型转换的冒号语法是 PostgreSQL 扩展，因此会导致冲突。</p>
</div>
<div class="REFSECT3"><a name="APP-PSQL-PROMPTING"></a><h4>提示符</h4>
<p><span class="APPLICATION">psql</span> 使用的提示符可以根据你的喜好自定义。三个变量 <tt class="VARNAME">PROMPT1</tt>, <tt class="VARNAME">PROMPT2</tt>, <tt class="VARNAME">PROMPT3</tt> 包含描述提示符的外观的字符串和特殊逃逸序列。<tt class="VARNAME">PROMPT1</tt> 是 <span class="APPLICATION">psql</span> 请求一个新命令时使用的正常提示符。<tt class="VARNAME">PROMPT2</tt> 是在一个命令输入期待更多输入时(因为查询没有用一个分号结束或者引号没有关闭)显示的提示符。<tt class="VARNAME">PROMPT3</tt> 在你运行一个 SQL <tt class="COMMAND">COPY</tt> 命令和等待你在终端上键入记录时使用。</p>
<p>相应的提示符变量的值是按字面打印的，除非碰到一个百分号(<tt class="LITERAL">%</tt>)。这时某些其它的文本被替换，替换为何物取决于下一个字符。已定义的替换是：</p>
<div class="VARIABLELIST">
<dl>
<dt><tt class="LITERAL">%M</tt></dt>
<dd><p>数据库服务器全程主机名(带着域名)，如果连接是通过 Unix 域套接字进行的就是 <tt class="LITERAL">[local]</tt> ，或者如果 Unix 域套接字不是编译的缺省位置，就是 <tt class="LITERAL">[local:<tt class="REPLACEABLE"><i>/dir/name</i></tt>]</tt></p></dd>
<dt><tt class="LITERAL">%m</tt></dt>
<dd><p>数据库服务器的主机名删去第一个点后面的部分剩下的东西。或者如果是通过 Unix 域套接字连接，就是 <tt class="LITERAL">[local]</tt></p></dd>
<dt><tt class="LITERAL">%&gt;</tt></dt>
<dd><p>数据库服务器正在侦听的端口号</p></dd>
<dt><tt class="LITERAL">%n</tt></dt>
<dd><p>数据库会话的用户名。这个值的扩展可能在一个数据库会话过程中因为 <tt class="COMMAND">SET SESSION AUTHORIZATION</tt> 命令而改变。</p></dd>
<dt><tt class="LITERAL">%/</tt></dt>
<dd><p>当前数据库名称</p></dd>
<dt><tt class="LITERAL">%~</tt></dt>
<dd><p>类似 <tt class="LITERAL">%/</tt> ，但如果数据库是你的缺省数据库输出是波浪线 <tt class="LITERAL">~</tt> </p></dd>
<dt><tt class="LITERAL">%#</tt></dt>
<dd><p>如果会话用户是数据库超级用户，使用 <tt class="LITERAL">#</tt> ，否则用 <tt class="LITERAL">&gt;</tt> 。这个值的扩展可能在一个数据库会话过程中因为 <tt class="COMMAND">SET SESSION AUTHORIZATION</tt> 命令而改变。</p></dd>
<dt><tt class="LITERAL">%R</tt></dt>
<dd><p>对于 <tt class="VARNAME">PROMPT1</tt> 通常是 <tt class="LITERAL">=</tt> ，但是如果是单行模式则是 <tt class="LITERAL">^</tt> ，而如果会话与数据库断开(如果 <tt class="COMMAND">\connect</tt> 失败可能发生)则是 <tt class="LITERAL">!</tt> 。对于 <tt class="VARNAME">PROMPT2</tt> 该序列被 <tt class="LITERAL">-</tt>, <tt class="LITERAL">*</tt>, 一个单引号/双引号/美元符(取决于 <span class="APPLICATION">psql</span> 是否等待更多的输入：查询没有终止、正在一个 <tt class="LITERAL">/* ... */</tt> 注释里、正在引号或者美元符扩展里)代替。 对于 <tt class="VARNAME">PROMPT3</tt> 该序列不解释成任何东西。</p></dd>
<dt><tt class="LITERAL">%x</tt></dt>
<dd><p>事务状态：如果不在事务块里则是一个空字符串，如果在事务块里则是 <tt class="LITERAL">*</tt> ，如果在一个失败的事务块里则是 <tt class="LITERAL">!</tt> ，或者无法判断事务状态时为 <tt class="LITERAL">?</tt> (比如没有连接)。</p></dd>
<dt><tt class="LITERAL">%</tt><tt class="REPLACEABLE"><i>digits</i></tt></dt>
<dd><p>指定字节值的字符将被替换到该位置。</p></dd>
<dt><tt class="LITERAL">%:</tt><tt class="REPLACEABLE"><i>name</i></tt><tt class="LITERAL">:</tt></dt>
<dd><p><span class="APPLICATION">psql</span> 变量 <tt class="REPLACEABLE"><i>name</i></tt> 的值。参阅<a href="app-psql.html#APP-PSQL-VARIABLES"><i>变量</i></a>小节获取细节。</p></dd>
<dt><tt class="LITERAL">%`</tt><tt class="REPLACEABLE"><i>command</i></tt><tt class="LITERAL">`</tt></dt>
<dd><p><tt class="REPLACEABLE"><i>command</i></tt> 的输出，类似于通常的"反勾号"替换。</p></dd>
<dt><tt class="LITERAL">%[</tt> ... <tt class="LITERAL">%]</tt></dt>
<dd><p>提示可以包含终端控制字符，这些字符可以改变颜色、背景、提示文本的风格、终端窗口的标题。为了让 <span class="APPLICATION">Readline</span> 的行编辑特性正确运行，这些不可打印的控制字符必须设计成不可见的，方法是用 <tt class="LITERAL">%[</tt> 和 <tt class="LITERAL">%]</tt> 包围它们。在提示符里可能出现这些东西的多个配对。例如</p>
<pre class="PROGRAMLISTING">testdb=&gt; \set PROMPT1 '%[%033[1;33;40m%]%n@%/%R%[%033[0m%]%# '</pre>
<p>的结果是在 VT100 兼容的可显示彩色的终端上的一个宽体(<tt class="LITERAL">1;</tt>)黑底黄字(<tt class="LITERAL">33;40</tt>)。</p></dd>
</dl>
</div>
<p>键入 <tt class="LITERAL">%%</tt> 可以在提示符里插入百分号。缺省提示符为 <tt class="LITERAL">'%/%R%# '</tt> 用于第一二个提示符，<tt class="LITERAL">'&gt;&gt; '</tt> 用于第三个提示符。</p>
<div class="NOTE">
<blockquote class="NOTE">
<p><b>【注意】</b>这个特性是从 <span class="APPLICATION">tcsh</span> 偷学来的。</p>
</blockquote>
</div>
</div>
<div class="REFSECT3"><a name="AEN59632"></a><h4>命令行编辑</h4>
<p><span class="APPLICATION">psql</span> 为了编辑和检索命令行的方便支持 <span class="APPLICATION">Readline</span> 和历史库。命令历史在 <span class="APPLICATION">psql</span> 退出的时候自动保存，在 <span class="APPLICATION">psql</span> 启动的时候加载。还支持 Tab 补齐，尽管该补齐逻辑并不是一个 SQL 分析器必备的。如果因某些原因你不喜欢 tab 补齐，可以把下面几行放在你的家目录下的 <tt class="FILENAME">.inputrc</tt> 文件里关闭这个特性：</p>
<pre class="PROGRAMLISTING">$if psql
set disable-completion on
$endif</pre>
<p>这不是 <span class="APPLICATION">psql</span> 而是 <span class="APPLICATION">Readline</span> 的特性，参考它的文档获取更多细节。</p>
</div>
</div>
</div>
<div class="REFSECT1"><a name="AEN59644"></a><h2>环境变量</h2>
<div class="VARIABLELIST">
<dl>
<dt><tt class="ENVAR">PAGER</tt></dt>
<dd><p>如果查询结果在一页里放不下，那么它们被重定向到这个命令。典型的值是 <tt class="LITERAL">more</tt> 或 <tt class="LITERAL">less</tt> 。缺省值是平台相关的。可以用 <tt class="COMMAND">\pset</tt> 命令关闭分页器。</p></dd>
<dt><tt class="ENVAR">PGDATABASE</tt></dt>
<dd><p>缺省连接的数据库</p></dd>
<dt><tt class="ENVAR">PGHOST</tt><br><tt class="ENVAR">PGPORT</tt><br><tt class="ENVAR">PGUSER</tt></dt>
<dd><p>缺省连接参数</p></dd>
<dt><tt class="ENVAR">PSQL_EDITOR</tt><br><tt class="ENVAR">EDITOR</tt><br><tt class="ENVAR">VISUAL</tt></dt>
<dd><p><tt class="COMMAND">\e</tt> 命令使用的编辑器。这些变量是按照上面的顺序检查的；设置最早的最先使用。</p></dd>
<dt><tt class="ENVAR">SHELL</tt></dt>
<dd><p><tt class="COMMAND">\!</tt> 命令执行的命令</p></dd>
<dt><tt class="ENVAR">TMPDIR</tt></dt>
<dd><p>存储临时文件的目录。缺省是 <tt class="FILENAME">/tmp</tt></p></dd>
</dl>
</div>
<p>因为 <span class="APPLICATION">psql</span> 在内部使用 <span class="APPLICATION">libpq</span> 库，所以所有 <span class="APPLICATION">libpq</span> 库的环境变量都可以被 <span class="APPLICATION">psql</span> 识别。参见<a href="libpq-envars.html">节29.12</a>获取所有变量的列表。</p>
</div>
<div class="REFSECT1"><a name="AEN59697"></a><h2>文件</h2>
<ul>
<li><p>在启动之前，<span class="APPLICATION">psql</span> 将会读取适用于系统范围的 <tt class="FILENAME">psqlrc</tt> 文件和执行来自用户家目录的文件 <tt class="FILENAME">~/.psqlrc</tt> 里面的命令。在 Windows 里，用户的启动文件名是 <tt class="FILENAME">%APPDATA%\postgresql\psqlrc.conf</tt> 。参阅 <tt class="FILENAME"><tt class="REPLACEABLE"><i>PREFIX</i></tt>/share/psqlrc.sample</tt> 获取如何设置全系统的文件的信息。可将它用于设置客户端或者服务器的风格(使用 <tt class="COMMAND">\set </tt>和 <tt class="COMMAND">SET</tt> 命令)。</p></li>
<li><p>系统范围的 <tt class="FILENAME">psqlrc</tt> 和用户自己的 <tt class="FILENAME">~/.psqlrc</tt> 都可以通过在后面附着一个划线和 PostgreSQL 版本号的方法变得与版本相关，比如 <tt class="FILENAME">~/.psqlrc-8.2.3</tt> 。匹配版本相关的文件比无版本的文件优先读取。</p></li>
<li><p>命令行历史存储在 <tt class="FILENAME">~/.psql_history</tt> 文件中，或者在 Windows 里是 <tt class="FILENAME">%APPDATA%\postgresql\psql_history</tt> 文件。</p></li>
</ul>
</div>
<div class="REFSECT1"><a name="AEN59720"></a><h2>注意</h2>
<ul>
<li><p>一些 <span class="APPLICATION">psql</span> 的早期版本允许一个单字母的反斜杠命令(元命令)的第一个参数直接跟在命令后面，而不用空白间隔。出于兼容性原因，这个特性仍然在某些程度上被支持，但是我不准备在这里详细解释，因为我不鼓励这样使用。不过如果你收到莫名其妙的信息，想想这个用法。例如</p>
<pre class="PROGRAMLISTING">testdb=&gt; <kbd class="USERINPUT">\foo</kbd>
Field separator is "oo".</pre>
<p>可能不是你想要的东西。</p></li>
<li><p><span class="APPLICATION">psql</span> 只能与同版本的服务器平稳地工作。这不意味着其它组合会完全失败，但是可能有微小的或者不那么微小的问题。如果服务器的版本不同，反斜杠命令是特别容易失效的。</p></li>
</ul>
</div>
<div class="REFSECT1"><a name="AEN59731"></a><h2>Windows 用户需要注意的地方</h2>
<p><span class="APPLICATION">psql</span> 是以一种"控制台应用"的方式制作的。因为 Windows 控制台窗口和系统其它部分使用不同的编码，所以在<span class="APPLICATION">psql</span> 里使用 8 位字符的时候必须采取特殊的注意措施。如果 <span class="APPLICATION">psql</span> 检测到一个有问题的控制台代码页，那么它在启动的时候会警告你。要修改控制台代码页，有两件事是必须做的：</p>
<ul>
<li><p>通过输入 <kbd class="USERINPUT">cmd.exe /c chcp 1252</kbd> 设置代码页。1252 是适用于德语的代码页；请换成合适你的数值，比如中文 GB2312 的代码页是 936 。如果你使用 Cygwin ，你可以在 <tt class="FILENAME">/etc/profile</tt> 里面输入这条命令。</p></li>
<li><p>控制台字体设置为 <tt class="LITERAL">Lucida Console</tt> ，因为光栅字体(点阵字体)不能在 ANSI 代码页下工作。</p></li>
</ul>
</div>
<div class="REFSECT1"><a name="APP-PSQL-EXAMPLES"></a><h2>例子</h2>
<p>第一个例子演示了如何把一个查询分成多个行进行输入。注意提示符的变化：</p>
<pre class="PROGRAMLISTING">testdb=&gt; <kbd class="USERINPUT">CREATE TABLE my_table (</kbd>
testdb(&gt; <kbd class="USERINPUT"> first integer not null default 0,</kbd>
testdb(&gt; <kbd class="USERINPUT"> second text)</kbd>
testdb-&gt; <kbd class="USERINPUT">;</kbd>
CREATE TABLE</pre>
<p>现在再看看表定义：</p>
<pre class="PROGRAMLISTING">testdb=&gt; <kbd class="USERINPUT">\d my_table</kbd>
             Table "my_table"
 Attribute |  Type   |      Modifier
-----------+---------+--------------------
 first     | integer | not null default 0
 second    | text    |&#13;</pre>
<p>把提示符变成更有趣的东西：</p>
<pre class="PROGRAMLISTING">testdb=&gt; <kbd class="USERINPUT">\set PROMPT1 '%n@%m %~%R%# '</kbd>
peter@localhost testdb=&gt;</pre>
<p>假设你用数据填充了表并且想看一眼：</p>
<pre class="PROGRAMLISTING">peter@localhost testdb=&gt; SELECT * FROM my_table;
 first | second
-------+--------
     1 | one
     2 | two
     3 | three
     4 | four
(4 rows)&#13;</pre>
<p>你可以用 <tt class="COMMAND">\pset</tt> 命令以不同的方法显示表：</p>
<pre class="PROGRAMLISTING">peter@localhost testdb=&gt; <kbd class="USERINPUT">\pset border 2</kbd>
Border style is 2.
peter@localhost testdb=&gt; <kbd class="USERINPUT">SELECT * FROM my_table;</kbd>
+-------+--------+
| first | second |
+-------+--------+
|     1 | one    |
|     2 | two    |
|     3 | three  |
|     4 | four   |
+-------+--------+
(4 rows)

peter@localhost testdb=&gt; <kbd class="USERINPUT">\pset border 0</kbd>
Border style is 0.
peter@localhost testdb=&gt; <kbd class="USERINPUT">SELECT * FROM my_table;</kbd>
first second
----- ------
    1 one
    2 two
    3 three
    4 four
(4 rows)

peter@localhost testdb=&gt; <kbd class="USERINPUT">\pset border 1</kbd>
Border style is 1.
peter@localhost testdb=&gt; <kbd class="USERINPUT">\pset format unaligned</kbd>
Output format is unaligned.
peter@localhost testdb=&gt; <kbd class="USERINPUT">\pset fieldsep ","</kbd>
Field separator is ",".
peter@localhost testdb=&gt; <kbd class="USERINPUT">\pset tuples_only</kbd>
Showing only tuples.
peter@localhost testdb=&gt; <kbd class="USERINPUT">SELECT second, first FROM my_table;</kbd>
one,1
two,2
three,3
four,4</pre>
<p>还可以用短(缩写)命令：</p>
<pre class="PROGRAMLISTING">peter@localhost testdb=&gt; <kbd class="USERINPUT">\a \t \x</kbd>
Output format is aligned.
Tuples only is off.
Expanded display is on.
peter@localhost testdb=&gt; <kbd class="USERINPUT">SELECT * FROM my_table;</kbd>
-[ RECORD 1 ]-
first  | 1
second | one
-[ RECORD 2 ]-
first  | 2
second | two
-[ RECORD 3 ]-
first  | 3
second | three
-[ RECORD 4 ]-
first  | 4
second | four</pre>
</div>
<div>
<hr align="LEFT" width="100%">
<table summary="Footer navigation table" width="100%" border="0" cellpadding="0" cellspacing="0">
<tr><td width="33%" align="left" valign="top"><a href="app-pgrestore.html" accesskey="P">后退</a></td><td width="34%" align="center" valign="top"><a href="index.html" accesskey="H">首页</a></td><td width="33%" align="right" valign="top"><a href="app-reindexdb.html" accesskey="N">前进</a></td></tr>
<tr><td width="33%" align="left" valign="top">pg_restore</td><td width="34%" align="center" valign="top"><a href="reference-client.html" accesskey="U">上一级</a></td><td width="33%" align="right" valign="top"><span class="APPLICATION">reindexdb</span></td></tr>
</table>
</div>
</body></html>