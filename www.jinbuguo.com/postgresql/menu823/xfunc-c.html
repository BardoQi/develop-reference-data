<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="zh-CN"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta http-equiv="Content-Language" content="zh-CN"><link href="stylesheet.css" media="all" rel="stylesheet" type="text/css">
<title>C 语言函数</title>
<script>var _hmt=_hmt||[]; (function(){ var hm=document.createElement("script"); hm.src="//hm.baidu.com/hm.js?d286c55b63a3c54a1e43d10d4c203e75"; var s=document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm,s); })();</script>
</head><body class="SECT1">
<div>
<table summary="Header navigation table" width="100%" border="0" cellpadding="0" cellspacing="0">
<tr><th colspan="5" align="center" valign="bottom">PostgreSQL 8.2.3 中文文档</th></tr>
<tr><td width="10%" align="left" valign="top"><a href="xfunc-internal.html" accesskey="P">后退</a></td><td width="10%" align="left" valign="top"><a href="extend.html">快退</a></td><td width="60%" align="center" valign="bottom">章33. 扩展 SQL</td><td width="10%" align="right" valign="top"><a href="extend.html">快进</a></td><td width="10%" align="right" valign="top"><a href="xaggr.html" accesskey="N">前进</a></td></tr>
</table>
<hr align="LEFT" width="100%"></div>
<div class="SECT1"><h1 class="SECT1"><a name="XFUNC-C">33.9. C 语言函数</a></h1><a name="AEN36584"></a>
<p>用户定义的函数可以用 C 写(或者是与C兼容的语言，比如C++)。这样的函数被编译进动态加载对象(共享库)并且由服务器根据需要加载。动态加载的特性是"C 语言函数"和"内部函数"之间的区别，不过，实际的编码习惯在两者之间实际上是一样的。因此，标准的内部函数库为写用户定义C函数提供了大量最好的样例。</p>
<p>目前对 C 函数有两种调用约定。新的"版本-1"的调用约定是通过为该函数书写一个 <tt class="LITERAL">PG_FUNCTION_INFO_V1()</tt> 宏来标识的，像下面演示的那样。缺少这个宏表示一个老风格的("版本-0")函数。两种风格里在 <tt class="COMMAND">CREATE FUNCTION</tt> 里声明的都是 <tt class="LITERAL">C</tt> 。现在老风格的函数已经废弃了，主要是因为移植性原因和缺乏功能，不过出于兼容性原因，系统仍然支持它。</p>
<div class="SECT2"><h2 class="SECT2"><a name="XFUNC-C-DYNLOAD">33.9.1. 动态加载</a></h2><a name="AEN36599"></a>
<p>当用户定义的函数第一次被服务器会话调用时，动态加载器才把可加载对象文件里的函数目标码加载进内存。因此，用于用户定义 C 函数的 <tt class="COMMAND">CREATE FUNCTION</tt> 必须为函数声明两个信息：可加载对象文件名、在目标文件里调用的 C 函数名(连接符号)。如果没有明确声明 C 函数名，那么就假设它与 SQL 函数名相同。</p>
<p>基于在 <tt class="COMMAND">CREATE FUNCTION</tt> 命令中给出的名字，下面的算法用于定位共享对象文件：</p>
<ol type="1">
<li><p>如果名字是一个绝对路径，则加载给出的文件。</p></li>
<li><p>如果名字以字符串 <tt class="LITERAL">$libdir</tt> 开头，那么该部分将被 PostgreSQL 库目录名代替，该目录是在编译时确定的。</p></li>
<li><p>如果名字不包含目录部分，那么在配置参数 <a href="runtime-config-client.html#GUC-DYNAMIC-LIBRARY-PATH">dynamic_library_path</a> 声明的路径里查找。</p></li>
<li><p>如果没有在路径里找到该文件，或者它包含一个非绝对目录部分，那么动态加载器就会试图直接拿这个名字来加载，这样几乎可以肯定是要失败的(依靠当前工作目录是不可靠的)。</p></li>
</ol>
<p>如果这个顺序不管用，那么就给这个名字加上平台相关的共享库文件扩展名(通常是 <tt class="FILENAME">.so</tt>)，然后再重新按照上面的过程找一遍。如果还是失败，那么加载失败。</p>
<p>建议使用相对于 <tt class="LITERAL">$libdir</tt> 的目录或者通过动态库路径定位共享库。这样，如果新版本安装在一个不同的位置，那么就可以简化版本升级。<tt class="LITERAL">$libdir</tt> 的实际目录位置可以用 <tt class="LITERAL">pg_config --pkglibdir</tt> 命令找到。</p>
<p>运行 PostgreSQL 服务器的用户必须可以遍历路径到达想加载的文件。一个常见的错误就是把该文件或者一个高层目录的权限设置为 <span class="SYSTEMITEM">postgres</span> 用户不可读和/或不能执行。</p>
<p>在任何情况下，在 <tt class="COMMAND">CREATE FUNCTION</tt> 命令里给出的文件名是在系统表里按照文本记录的，因此，如果需要再次加载，那么会再次运行这个过程。</p>
<div class="NOTE">
<blockquote class="NOTE">
<p><b>【注意】</b>PostgreSQL 不会自动编译 C 函数；在使用 <tt class="COMMAND">CREATE FUNCTION</tt> 命令之前你必须编译它。参阅<a href="xfunc-c.html#DFUNC">节33.9.6</a>获取更多信息。</p>
</blockquote>
</div>
<a name="AEN36636"></a>
<p>为了确保不会错误加载共享库文件，从 PostgreSQL 8.2 开始将检查那个文件的"magic block"以确保版本兼容性。要包含"magic block"，请在包含了 <tt class="FILENAME">fmgr.h</tt> 头文件之后，将下面的内容写进一个(也只能是一个)模块的源代码文件中：</p>
<pre class="PROGRAMLISTING">#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif</pre>
<p>如果不打算兼容 8.2 之前的版本，<tt class="LITERAL">#ifdef</tt> 测试也可以省略。</p>
<p>动态加载对象文件在首次使用之后将一直滞留在内存中。在同一个会话中的下一次调用将只需查找符号表的很小开销。如果你想强制重新加载(比如重新编译之后)，可以使用 <a href="sql-load.html"><i>LOAD</i></a> 命令或者重新开始一个新的会话。</p>
<a name="AEN36649"></a><a name="AEN36651"></a><a name="AEN36653"></a><a name="AEN36655"></a>
<p>动态加载文件也可以包含初始化函数和结束函数。如果包含一个名为 <code class="FUNCTION">_PG_init</code> 的函数，那么该函数将在该文件被加载后立即执行，该函数不能接受任何参数并且必须返回 void 。如果包含一个名为 <code class="FUNCTION">_PG_fini</code>  的函数，那么该函数将在该文件即将被卸载前执行，同样，该函数不能接受任何参数并且必须返回 void 。需要注意的是 <code class="FUNCTION">_PG_fini</code> 仅在该文件即将被卸载前执行而不是在会话结束的时候执行。目前，仅在明确使用 <tt class="COMMAND">LOAD</tt> 命令重新加载文件的时候才会导致卸载先前加载的文件。</p>
</div>
<div class="SECT2"><h2 class="SECT2"><a name="XFUNC-C-BASETYPE">33.9.2. 基本类型的 C 语言函数</a></h2><a name="AEN36664"></a>
<p>要知道如何写 C 语言函数，就必须知道 PostgreSQL 在内部如何表现基本数据类型以及如何传入及传出函数。PostgreSQL 内部把基本类型当作"一块内存"看待。定义在某种类型上的用户定义函数实际上定义了 PostgreSQL 对该数据类型可能的操作。也就是说，PostgreSQL 只是从磁盘读取和存储该数据类型并使用你定义的函数来输入、处理、输出数据。</p>
<p>基本类型可以有下面三种内部形态(格式)之一：</p>
<ul>
<li><p>传递数值，定长</p></li>
<li><p>传递引用，定长</p></li>
<li><p>传递引用，变长</p></li>
</ul>
<p>传递数值的类型长度只能是 1, 2, 4 字节。如果 <tt class="LITERAL">sizeof(Datum)</tt> 在你的机器上是 8 的话，那么还有 8 字节。你要仔细定义你的类型，确保它们在任何体系平台上都是相同尺寸(字节)。例如，<tt class="LITERAL">long</tt> 是一个危险的类型，因为在一些机器上它是 4 字节而在另外一些机器上是 8 字节，而 <tt class="TYPE">int</tt> 在大多数 Unix 机器上都是 4 字节的。在一个 Unix 机器上的 <tt class="TYPE">int4</tt> 合理实现可能是：</p>
<pre class="PROGRAMLISTING">/* 4-字节整数，传值 */
typedef int int4;</pre>
<p>另外，任何尺寸的定长类型都可以是传递引用型。例如，下面是一个 PostgreSQL 类型的实现：</p>
<pre class="PROGRAMLISTING">/* 16-字节结构，传递引用 */
typedef struct
{
    double  x, y;
} Point;</pre>
<p>只能使用指向这些类型的指针在 PostgreSQL 函数里传入和传出数据。要返回这样类型的值，用 <tt class="LITERAL">palloc</tt> 分配正确数量的内存，填充这些内存，然后返回一个指向它的指针。如果只是想返回和输入参数类型与数值都相同的数值，可以忽略额外的 <tt class="LITERAL">palloc</tt> ，只要返回指向输入数值的指针就行。</p>
<p>最后，所有变长类型同样也只能通过引用来传递。所有变长类型必须以一个 4 字节的长度域开始，并且所有存储在该类型中的数据必须放在紧接着长度域的存储空间里。长度域是结构的全长，也就是说，包括长度域本身的长度。</p>
<div class="WARNING">
<table class="WARNING" border="1" width="100%">
<tr><td align="CENTER"><b>警告</b></td></tr>
<tr><td align="LEFT"><p><span class="emphasis"><i class="EMPHASIS">绝对不要</i></span>修改一个引用传递的输入值，否则很可能破坏磁盘上的数据。因为指针很可能直接指向一个磁盘缓冲区。这条规则的唯一例外在<a href="xaggr.html">节33.10</a>里。</p></td></tr>
</table>
</div>
<p>比如，我们可以用下面的方法定义一个 <tt class="TYPE">text</tt> 类型：</p>
<pre class="PROGRAMLISTING">typedef struct {
    int4 length;
    char data[1];
} text;</pre>
<p>显然，上面声明的数据域长度不足以存储任何可能的字符串。因为在 C 中不可能声明变长结构，所以我们倚赖这样的知识：C 编译器不会对数组下标进行范围检查。只需要分配足够的空间，然后把数组当做已经声明为合适长度的变量访问。这是一个常用的技巧，你可以在许多 C 教科书中读到。</p>
<p>当处理变长类型时，必须仔细分配正确的内存数量并正确设置长度域。例如，如果想在一个 <tt class="STRUCTNAME">text</tt> 结构里存储 40 字节，我们可能会使用像下面的代码片段：</p>
<pre class="PROGRAMLISTING">#include "postgres.h"
...
char buffer[40]; /* 我们的源数据 */
...
text *destination = (text *) palloc(VARHDRSZ + 40);
destination-&gt;length = VARHDRSZ + 40;
memcpy(destination-&gt;data, buffer, 40);
...</pre>
<p><tt class="LITERAL">VARHDRSZ</tt> 等价于 <tt class="LITERAL">sizeof(int4)</tt> ，但是我们认为用宏 <tt class="LITERAL">VARHDRSZ</tt> 表示附加尺寸是用于变长类型的更好风格。</p>
<p><a href="xfunc-c.html#XFUNC-C-TYPE-TABLE">表33-1</a>列出了书写使用 PostgreSQL 内置类型的 C 函数里需要知道的 SQL 类型与 C 类型的对应关系。"定义在"列给出了需要包含以获取该类型定义的头文件。注意，你应该总是首先包括 <tt class="FILENAME">postgres.h</tt> ，因为它声明了许多你需要的东西。</p>
<div class="TABLE"><a name="XFUNC-C-TYPE-TABLE"></a>
<p><b>表33-1. 与内建 SQL 类型等效的 C 类型</b></p>
<table border="1" class="CALSTABLE"><col><col><col>
<thead>
<tr><th>SQL 类型</th><th>C 类型</th><th>定义在</th></tr>
</thead>
<tbody>
<tr><td><tt class="TYPE">abstime</tt></td><td><tt class="TYPE">AbsoluteTime</tt></td><td><tt class="FILENAME">utils/nabstime.h</tt></td></tr>
<tr><td><tt class="TYPE">boolean</tt></td><td><tt class="TYPE">bool</tt></td><td><tt class="FILENAME">postgres.h</tt>(可能是编译器内置)</td></tr>
<tr><td><tt class="TYPE">box</tt></td><td><tt class="TYPE">BOX*</tt></td><td><tt class="FILENAME">utils/geo_decls.h</tt></td></tr>
<tr><td><tt class="TYPE">bytea</tt></td><td><tt class="TYPE">bytea*</tt></td><td><tt class="FILENAME">postgres.h</tt></td></tr>
<tr><td><tt class="TYPE">"char"</tt></td><td><tt class="TYPE">char</tt></td><td>(编译器内置)</td></tr>
<tr><td><tt class="TYPE">character</tt></td><td><tt class="TYPE">BpChar*</tt></td><td><tt class="FILENAME">postgres.h</tt></td></tr>
<tr><td><tt class="TYPE">cid</tt></td><td><tt class="TYPE">CommandId</tt></td><td><tt class="FILENAME">postgres.h</tt></td></tr>
<tr><td><tt class="TYPE">date</tt></td><td><tt class="TYPE">DateADT</tt></td><td><tt class="FILENAME">utils/date.h</tt></td></tr>
<tr><td><tt class="TYPE">smallint</tt> (<tt class="TYPE">int2</tt>)</td><td><tt class="TYPE">int2</tt> 或 <tt class="TYPE">int16</tt></td><td><tt class="FILENAME">postgres.h</tt></td></tr>
<tr><td><tt class="TYPE">int2vector</tt></td><td><tt class="TYPE">int2vector*</tt></td><td><tt class="FILENAME">postgres.h</tt></td></tr>
<tr><td><tt class="TYPE">integer</tt> (<tt class="TYPE">int4</tt>)</td><td><tt class="TYPE">int4</tt> 或 <tt class="TYPE">int32</tt></td><td><tt class="FILENAME">postgres.h</tt></td></tr>
<tr><td><tt class="TYPE">real</tt> (<tt class="TYPE">float4</tt>)</td><td><tt class="TYPE">float4*</tt></td><td><tt class="FILENAME">postgres.h</tt></td></tr>
<tr><td><tt class="TYPE">double precision</tt> (<tt class="TYPE">float8</tt>)</td><td><tt class="TYPE">float8*</tt></td><td><tt class="FILENAME">postgres.h</tt></td></tr>
<tr><td><tt class="TYPE">interval</tt></td><td><tt class="TYPE">Interval*</tt></td><td><tt class="FILENAME">utils/timestamp.h</tt></td></tr>
<tr><td><tt class="TYPE">lseg</tt></td><td><tt class="TYPE">LSEG*</tt></td><td><tt class="FILENAME">utils/geo_decls.h</tt></td></tr>
<tr><td><tt class="TYPE">name</tt></td><td><tt class="TYPE">Name</tt></td><td><tt class="FILENAME">postgres.h</tt></td></tr>
<tr><td><tt class="TYPE">oid</tt></td><td><tt class="TYPE">Oid</tt></td><td><tt class="FILENAME">postgres.h</tt></td></tr>
<tr><td><tt class="TYPE">oidvector</tt></td><td><tt class="TYPE">oidvector*</tt></td><td><tt class="FILENAME">postgres.h</tt></td></tr>
<tr><td><tt class="TYPE">path</tt></td><td><tt class="TYPE">PATH*</tt></td><td><tt class="FILENAME">utils/geo_decls.h</tt></td></tr>
<tr><td><tt class="TYPE">point</tt></td><td><tt class="TYPE">POINT*</tt></td><td><tt class="FILENAME">utils/geo_decls.h</tt></td></tr>
<tr><td><tt class="TYPE">regproc</tt></td><td><tt class="TYPE">regproc</tt></td><td><tt class="FILENAME">postgres.h</tt></td></tr>
<tr><td><tt class="TYPE">reltime</tt></td><td><tt class="TYPE">RelativeTime</tt></td><td><tt class="FILENAME">utils/nabstime.h</tt></td></tr>
<tr><td><tt class="TYPE">text</tt></td><td><tt class="TYPE">text*</tt></td><td><tt class="FILENAME">postgres.h</tt></td></tr>
<tr><td><tt class="TYPE">tid</tt></td><td><tt class="TYPE">ItemPointer</tt></td><td><tt class="FILENAME">storage/itemptr.h</tt></td></tr>
<tr><td><tt class="TYPE">time</tt></td><td><tt class="TYPE">TimeADT</tt></td><td><tt class="FILENAME">utils/date.h</tt></td></tr>
<tr><td><tt class="TYPE">time with time zone</tt></td><td><tt class="TYPE">TimeTzADT</tt></td><td><tt class="FILENAME">utils/date.h</tt></td></tr>
<tr><td><tt class="TYPE">timestamp</tt></td><td><tt class="TYPE">Timestamp*</tt></td><td><tt class="FILENAME">utils/timestamp.h</tt></td></tr>
<tr><td><tt class="TYPE">tinterval</tt></td><td><tt class="TYPE">TimeInterval</tt></td><td><tt class="FILENAME">utils/nabstime.h</tt></td></tr>
<tr><td><tt class="TYPE">varchar</tt></td><td><tt class="TYPE">VarChar*</tt></td><td><tt class="FILENAME">postgres.h</tt></td></tr>
<tr><td><tt class="TYPE">xid</tt></td><td><tt class="TYPE">TransactionId</tt></td><td><tt class="FILENAME">postgres.h</tt></td></tr>
</tbody>
</table>
</div>
<p>既然我们已经讨论了基本类型所有可能的结构，我们便可以用实际的函数举一些例子。</p>
</div>
<div class="SECT2"><h2 class="SECT2"><a name="AEN36939">33.9.3. 版本-0 调用约定</a></h2>
<p>先提供现在已经不提倡了的"老风格"，因为比较容易迈出第一步。此风格 C 函数的参数和结果用普通 C 风格声明，但是要小心使用上面显示的 SQL 数据类型的 C 表现形式。</p>
<p>下面是一些例子：</p>
<pre class="PROGRAMLISTING">#include "postgres.h"
#include &lt;string.h&gt;

/* 传递数值 */
         
int
add_one(int arg)
{
    return arg + 1;
}

/* 传递引用，定长 */

float8 *
add_one_float8(float8 *arg)
{
    float8    *result = (float8 *) palloc(sizeof(float8));

    *result = *arg + 1.0;
       
    return result;
}

Point *
makepoint(Point *pointx, Point *pointy)
{
    Point     *new_point = (Point *) palloc(sizeof(Point));

    new_point-&gt;x = pointx-&gt;x;
    new_point-&gt;y = pointy-&gt;y;
       
    return new_point;
}

/* 传递引用，变长 */

text *
copytext(text *t)
{
    /*
     * VARSIZE 是结构以字节计的总长度
     */
    text *new_t = (text *) palloc(VARSIZE(t));
    VARATT_SIZEP(new_t) = VARSIZE(t);
    /*
     * VARDATA 是结构中一个指向数据区的指针
     */
    memcpy((void *) VARDATA(new_t), /* destination */
           (void *) VARDATA(t),     /* source */
           VARSIZE(t) - VARHDRSZ);  /* how many bytes */
    return new_t;
}

text *
concat_text(text *arg1, text *arg2)
{
    int32 new_text_size = VARSIZE(arg1) + VARSIZE(arg2) - VARHDRSZ;
    text *new_text = (text *) palloc(new_text_size);

    VARATT_SIZEP(new_text) = new_text_size;
    memcpy(VARDATA(new_text), VARDATA(arg1), VARSIZE(arg1) - VARHDRSZ);
    memcpy(VARDATA(new_text) + (VARSIZE(arg1) - VARHDRSZ),
           VARDATA(arg2), VARSIZE(arg2) - VARHDRSZ);
    return new_text;
}</pre>
<p>假设上面的代码放在 <tt class="FILENAME">funcs.c</tt> 文件中并且编译成了共享目标，我们可以用下面的命令为 PostgreSQL 定义这些函数：</p>
<pre class="PROGRAMLISTING">CREATE FUNCTION add_one(integer) RETURNS integer
     AS '<tt class="REPLACEABLE"><i>DIRECTORY</i></tt>/funcs', 'add_one'
     LANGUAGE C STRICT;

-- 注意：重载了名字为 add_one() 的 SQL 函数
CREATE FUNCTION add_one(double precision) RETURNS double precision
     AS '<tt class="REPLACEABLE"><i>DIRECTORY</i></tt>/funcs', 'add_one_float8'
     LANGUAGE C STRICT;

CREATE FUNCTION makepoint(point, point) RETURNS point
     AS '<tt class="REPLACEABLE"><i>DIRECTORY</i></tt>/funcs', 'makepoint'
     LANGUAGE C STRICT;
                         
CREATE FUNCTION copytext(text) RETURNS text
     AS '<tt class="REPLACEABLE"><i>DIRECTORY</i></tt>/funcs', 'copytext'
     LANGUAGE C STRICT;

CREATE FUNCTION concat_text(text, text) RETURNS text
     AS '<tt class="REPLACEABLE"><i>DIRECTORY</i></tt>/funcs', 'concat_text'
     LANGUAGE C STRICT;</pre>
<p>这里的 <tt class="REPLACEABLE"><i>DIRECTORY</i></tt> 代表共享库文件的目录，比如包含本节示例代码的 PostgreSQL 教程目录。更好的风格应该是将 <tt class="REPLACEABLE"><i>DIRECTORY</i></tt> 加到搜索路径之后，在 <tt class="LITERAL">AS</tt> 子句里只使用 <tt class="LITERAL">'funcs'</tt> ，不管怎样，我们都可以省略和系统相关的共享库扩展，通常是 <tt class="LITERAL">.so</tt> 或 <tt class="LITERAL">.sl</tt> 。</p>
<p>请注意我们把函数声明为"strict"(严格)，意思是说如果任何输入值为 NULL ，那么系统应该自动假设一个 NULL 的结果。这样处理可以让我们避免在函数代码里面检查 NULL 输入。如果不这样处理，我们就得明确检查 NULL ，比如为每个传递引用的参数检查空指针。对于传值类型的参数，我们甚至没有办法检查！</p>
<p>尽管这种老调用风格用起来简单，但它却不太容易移植；在一些系统上，用这种方法传递比 <tt class="TYPE">int</tt> 小的数据类型就会碰到困难。而且，我们没有很好的返回 NULL 结果的办法，也没有除了把函数严格化以外的处理 NULL 参数的方法。下面要讲的新方法则解决了这些问题。</p>
</div>
<div class="SECT2"><h2 class="SECT2"><a name="AEN36966">33.9.4. 版本-1 调用约定</a></h2>
<p>版本-1 调用约定使用宏消除大多数传递参数和结果的复杂性。版本-1 风格函数的C定义总是下面这样</p>
<pre class="PROGRAMLISTING">Datum funcname(PG_FUNCTION_ARGS)</pre>
<p>另外，下面的宏</p>
<pre class="PROGRAMLISTING">PG_FUNCTION_INFO_V1(funcname);</pre>
<p>也必须出现在同一个源文件里(通常就可以写在函数自身前面)。对那些 <tt class="LITERAL">internal</tt> 语言函数而言，不需要调用这个宏，因为 PostgreSQL 目前假设内部函数都是版本-1 。不过，对于动态加载的函数，它是必须的。</p>
<p>在版本-1 函数里，每个实际参数都是用一个对应该参数数据类型的 <code class="FUNCTION">PG_GETARG_<tt class="REPLACEABLE"><i>xxx</i></tt>()</code> 宏抓取的，用返回类型的 <code class="FUNCTION">PG_RETURN_<tt class="REPLACEABLE"><i>xxx</i></tt>()</code> 宏返回结果。<code class="FUNCTION">PG_GETARG_<tt class="REPLACEABLE"><i>xxx</i></tt>()</code> 接受要抓取的函数参数的编号(从 0 开始)作为其参数。<code class="FUNCTION">PG_RETURN_<tt class="REPLACEABLE"><i>xxx</i></tt>()</code> 接受实际要返回的数值为自身的参数。</p>
<p>下面是和上面一样的函数，但是是用版本-1 风格编写的：</p>
<pre class="PROGRAMLISTING">#include "postgres.h"
#include &lt;string.h&gt;
#include "fmgr.h"

/* 传递数值 */

PG_FUNCTION_INFO_V1(add_one);
         
Datum
add_one(PG_FUNCTION_ARGS)
{
    int32   arg = PG_GETARG_INT32(0);

    PG_RETURN_INT32(arg + 1);
}

/* 传递引用，定长 */

PG_FUNCTION_INFO_V1(add_one_float8);

Datum
add_one_float8(PG_FUNCTION_ARGS)
{
    /* 用于 FLOAT8 的宏，隐藏其传递引用的本质 */
    float8   arg = PG_GETARG_FLOAT8(0);

    PG_RETURN_FLOAT8(arg + 1.0);
}

PG_FUNCTION_INFO_V1(makepoint);

Datum
makepoint(PG_FUNCTION_ARGS)
{
    /* 这里，我们没有隐藏 Point 的传递引用的本质 */
    Point     *pointx = PG_GETARG_POINT_P(0);
    Point     *pointy = PG_GETARG_POINT_P(1);
    Point     *new_point = (Point *) palloc(sizeof(Point));

    new_point-&gt;x = pointx-&gt;x;
    new_point-&gt;y = pointy-&gt;y;
       
    PG_RETURN_POINT_P(new_point);
}

/* 传递引用，变长 */

PG_FUNCTION_INFO_V1(copytext);

Datum
copytext(PG_FUNCTION_ARGS)
{
    text     *t = PG_GETARG_TEXT_P(0);
    /*
     * VARSIZE 是结构以字节计的总长度
     */
    text     *new_t = (text *) palloc(VARSIZE(t));
    VARATT_SIZEP(new_t) = VARSIZE(t);
    /*
     * VARDATA 是结构中指向数据区的一个指针
     */
    memcpy((void *) VARDATA(new_t), /* 目的 */
           (void *) VARDATA(t),     /* 源 */
           VARSIZE(t) - VARHDRSZ);  /* 多少字节 */
    PG_RETURN_TEXT_P(new_t);
}

PG_FUNCTION_INFO_V1(concat_text);

Datum
concat_text(PG_FUNCTION_ARGS)
{
    text  *arg1 = PG_GETARG_TEXT_P(0);
    text  *arg2 = PG_GETARG_TEXT_P(1);
    int32 new_text_size = VARSIZE(arg1) + VARSIZE(arg2) - VARHDRSZ;
    text *new_text = (text *) palloc(new_text_size);

    VARATT_SIZEP(new_text) = new_text_size;
    memcpy(VARDATA(new_text), VARDATA(arg1), VARSIZE(arg1) - VARHDRSZ);
    memcpy(VARDATA(new_text) + (VARSIZE(arg1) - VARHDRSZ),
           VARDATA(arg2), VARSIZE(arg2) - VARHDRSZ);
    PG_RETURN_TEXT_P(new_text);
}</pre>
<p>用到的 <tt class="COMMAND">CREATE FUNCTION</tt> 命令和用于老风格的等效命令一样。</p>
<p>猛一看，版本-1 的编码好像只是无目的地蒙人。但是它的确给我们许多改进，因为宏可以隐藏许多不必要的细节。一个例子在 <code class="FUNCTION">add_one_float8</code> 的编码里，这里我们不再需要不停叮嘱自己 <tt class="TYPE">float8</tt> 是传递引用类型。另外一个例子是用于变长类型的宏 <tt class="LITERAL">GETARG</tt> 隐藏了抓取"非常规"(压缩的或者超长的)值需要做的处理。</p>
<p>版本-1 的函数另一个巨大的改进是对 NULL 输入和结果的处理。宏 <code class="FUNCTION">PG_ARGISNULL(<tt class="REPLACEABLE"><i>n</i></tt>)</code> 允许一个函数测试每个输入是否为 NULL ，当然，这只是对那些没有声明为"strict"的函数有必要。因为如果有 <code class="FUNCTION">PG_GETARG_<tt class="REPLACEABLE"><i>xxx</i></tt>()</code> 宏，输入参数是从零开始计算的。请注意我们不应该执行 <code class="FUNCTION">PG_GETARG_<tt class="REPLACEABLE"><i>xxx</i></tt>()</code> ，除非有人声明了参数不是 NULL 。要返回一个 NULL 结果，可以执行一个 <code class="FUNCTION">PG_RETURN_NULL()</code> ，这样对严格的和不严格的函数都有效。</p>
<p>在新风格的接口中提供的其它选项是 <code class="FUNCTION">PG_GETARG_<tt class="REPLACEABLE"><i>xxx</i></tt>()</code> 宏的两个变种。第一个变体 <code class="FUNCTION">PG_GETARG_<tt class="REPLACEABLE"><i>xxx</i></tt>_COPY()</code> 保证返回一个指定参数的副本，该副本是可以安全地写入的。普通的宏有时候会返回一个指向物理存储在表中的某值的指针，因此我们不能写入该指针。用 <code class="FUNCTION">PG_GETARG_<tt class="REPLACEABLE"><i>xxx</i></tt>_COPY()</code> 宏保证获取一个可写的结果。第二个变体由 <code class="FUNCTION">PG_GETARG_<tt class="REPLACEABLE"><i>xxx</i></tt>_SLICE()</code> 宏组成，它接受三个参数。第一个是参数的个数(与上同)。第二个和第三个是要返回的偏移量和数据段的长度。偏移是从零开始计算的，一个负数的长度则要求返回该值的剩余长度的数据。这些过程提供了访问大数据值的中一部分的更有效方法，特别是数据的存储类型是"external"的时候。一个字段的存储类型可以用 <tt class="LITERAL">ALTER TABLE <tt class="REPLACEABLE"><i>tablename</i></tt> ALTER COLUMN <tt class="REPLACEABLE"><i>colname</i></tt> SET STORAGE <tt class="REPLACEABLE"><i>storagetype</i></tt></tt> 指定。<tt class="REPLACEABLE"><i>storagetype</i></tt> 是 <tt class="LITERAL">plain</tt>, <tt class="LITERAL">external</tt>, <tt class="LITERAL">extended</tt>, <tt class="LITERAL">main</tt> 之一。</p>
<p>版本-1 的函数调用风格也令我们可能返回一"套"结果(<a href="xfunc-c.html#XFUNC-C-RETURN-SET">节33.9.10</a>)并且实现触发器函数(<a href="triggers.html">章34</a>)和过程语言调用处理器(<a href="plhandler.html">章47</a>)。版本-1 的代码也更容易移植，因为它没有违反 C 标准对函数调用协议的限制。更多的细节请参阅源程序中的 <tt class="FILENAME">src/backend/utils/fmgr/README</tt> 文件。</p>
</div>
<div class="SECT2"><h2 class="SECT2"><a name="AEN37024">33.9.5. 书写代码</a></h2>
<p>在转到更深的话题之前，先要讨论一些 PostgreSQL C 语言函数的编码规则。虽然可以用 C 以外的其它语言(C++, FORTRAN, Pascal)书写用于 PostgreSQL 的共享函数，但通常都很麻烦，因为它们并不遵循 C 的调用习惯。也就是说，其它语言与 C 的传递参数和返回值的方式不一样。因此假设你的编程语言函数是用 C 写的。</p>
<p>书写和编译 C 函数的基本规则如下：</p>
<ul>
<li><p>使用 <tt class="LITERAL">pg_config --includedir-server</tt> 找出 PostgreSQL 服务器的头文件安装位置。</p></li>
<li><p>把你的代码编译成可以动态装入 PostgreSQL 的库文件总是需要一些特殊的标记。参阅<a href="xfunc-c.html#DFUNC">节33.9.6</a>获取如何在你的平台上做这件事的详细说明。</p></li>
<li><p>按照<a href="xfunc-c.html#XFUNC-C-DYNLOAD">节33.9.1</a>的指示为你的共享库定义一个"magic block"。</p></li>
<li><p>当分配内存时，用 PostgreSQL 的 <code class="FUNCTION">palloc</code> 和 <code class="FUNCTION">pfree</code> 函数取代相应的 C 库函数 <code class="FUNCTION">malloc</code> 和 <code class="FUNCTION">free</code> 。用 <code class="FUNCTION">palloc</code> 分配的内存在每个事务结束时会自动释放，避免了内存泄露。</p></li>
<li><p>记得用 <code class="FUNCTION">memset</code> 对结构字节清零。如果不这么做，就很难支持 Hash 索引和 Hash 连接，因为必须从数据结构中选出最具特征的位来计算 Hash 。即使你初始化了结构的所有域，仍然有可能有几个对齐字节(结构中的洞)含有垃圾值。</p></li>
<li><p>大多数的 PostgreSQL 内部类型定义在 <tt class="FILENAME">postgres.h</tt> 中，而函数管理器接口(<tt class="SYMBOL">PG_FUNCTION_ARGS</tt> 等等)都在 <tt class="FILENAME">fmgr.h</tt> 中，所以你至少应该包括这两个文件。出于移植性原因，最好<span class="emphasis"><i class="EMPHASIS">先</i></span>包括 <tt class="FILENAME">postgres.h</tt> 再包括其它系统或者用户头文件。包含 <tt class="FILENAME">postgres.h</tt> 将自动包含 <tt class="FILENAME">elog.h</tt> 和 <tt class="FILENAME">palloc.h</tt> 。</p></li>
<li><p>在目标文件里定义的符号一定不能相互冲突，也不能和定义在 PostgreSQL 服务器可执行代码中的符号名字冲突。如果你看到了与此相关的错误信息，那么必须重命名你的函数或者变量。</p></li>
</ul>
</div>
<div class="SECT2"><h2 class="SECT2"><a name="DFUNC">33.9.6. 编译和链接动态加载的函数</a></h2>
<p>在能够使用由 C 写的 PostgreSQL 扩展函数之前，必须用一种特殊的方法编译和链接它们，这样才能生成可以被服务器动态加载的文件。准确地说是需要创建一个<i class="FIRSTTERM">共享库</i>。</p>
<p>如果需要更多信息，那么你应该阅读操作系统的文档，特别是 C 编译器(<tt class="COMMAND">cc</tt>)和连接器(<tt class="COMMAND">ld</tt>)的文档。另外，PostgreSQL 源代码里包含几个可以运行的例子，它们在 <tt class="FILENAME">contrib</tt> 目录里。不过，如果你依赖这些例子，那么你的模块将依赖于 PostgreSQL 源代码的可用性。</p>
<p>创建共享库和链接可执行文件类似：首先把源代码编译成目标文件，然后把目标文件链接起来。目标文件需要创建成<i class="FIRSTTERM">位置无关码</i>(PIC)，也就是在可执行程序加载它们的时候，它们可以被放在可执行程序内存里的任何地方(用于可执行文件的目标文件通常不是用这个方式编译的)，链接动态库的命令包含特殊标志，与链接可执行文件的命令是有区别的(至少理论上如此，不过现实未必)。</p>
<p>在下面的例子里，假设你要将源程序代码 <tt class="FILENAME">foo.c</tt> 编译成名字叫 <tt class="FILENAME">foo.so</tt> 的共享库，中介的对象文件将叫做 <tt class="FILENAME">foo.o</tt>(除非另外注明)。虽然一个共享库可以包含多个对象文件，但是在这里只用一个。</p>
<div class="VARIABLELIST">
<dl>
<dt><span class="SYSTEMITEM">BSD/OS</span></dt>
<dd><p>创建 PIC 的编译器标志是 <tt class="OPTION">-fpic</tt> 。创建共享库的链接器标志是 <tt class="OPTION">-shared</tt> 。</p>
<pre class="PROGRAMLISTING">gcc -fpic -c foo.c
ld -shared -o foo.so foo.o</pre>
<p>上面方法适用于 4.0 版本的 <span class="SYSTEMITEM">BSD/OS</span> 。</p></dd>
<dt><span class="SYSTEMITEM">FreeBSD</span></dt>
<dd><p>创建 PIC 的编译器标志是  <tt class="OPTION">-fpic</tt> 。创建共享库的链接器标志是 <tt class="OPTION">-shared</tt> 。</p>
<pre class="PROGRAMLISTING">gcc -fpic -c foo.c
gcc -shared -o foo.so foo.o</pre>
<p>上面方法适用于 3.0 版本的 <span class="SYSTEMITEM">FreeBSD</span> 。</p></dd>
<dt><span class="SYSTEMITEM">HP-UX</span></dt>
<dd><p>创建 PIC 的编译器标志是  <tt class="OPTION">+z</tt> 。如果使用 <span class="APPLICATION">GCC</span> 则是 <tt class="OPTION">-fpic</tt> 。创建共享库的链接器标志是 <tt class="OPTION">-b</tt> 。因此</p>
<pre class="PROGRAMLISTING">cc +z -c foo.c</pre>
<p>或</p>
<pre class="PROGRAMLISTING">gcc -fpic -c foo.c</pre>
<p>然后</p>
<pre class="PROGRAMLISTING">ld -b -o foo.sl foo.o</pre>
<p><span class="SYSTEMITEM">HP-UX</span> 使用 <tt class="FILENAME">.sl</tt> 作为共享库扩展名，和其它大部分系统不同。</p></dd>
<dt><span class="SYSTEMITEM">IRIX</span></dt>
<dd><p>PIC 是缺省，不需要使用特殊的编译器选项。创建共享库的链接器标志是 <tt class="OPTION">-shared</tt> 。</p>
<pre class="PROGRAMLISTING">cc -c foo.c
ld -shared -o foo.so foo.o</pre></dd>
<dt><span class="SYSTEMITEM">Linux</span></dt>
<dd><p>创建 PIC 的编译器标志是 <tt class="OPTION">-fpic</tt> 。在某些平台上则是 <tt class="OPTION">-fPIC</tt> 。参考 GCC 手册获取更多信息。创建共享库的编译器标志是 <tt class="OPTION">-shared</tt> 。一个完整的例子看起来像：</p>
<pre class="PROGRAMLISTING">cc -fpic -c foo.c
cc -shared -o foo.so foo.o</pre></dd>
<dt><span class="SYSTEMITEM">MacOS X</span></dt>
<dd><p>这里是一个例子(假设开发工具已经安装好了)。</p>
<pre class="PROGRAMLISTING">cc -c foo.c 
cc -bundle -flat_namespace -undefined suppress -o foo.so foo.o</pre></dd>
<dt><span class="SYSTEMITEM">NetBSD</span></dt>
<dd><p>创建 PIC 的编译器标志是  <tt class="OPTION">-fpic</tt> 。对于 ELF 系统，带 <tt class="OPTION">-shared</tt> 标志的编译命令用于链接共享库。在老的非 ELF 系统里，则使用 <tt class="LITERAL">ld -Bshareable</tt> 。</p>
<pre class="PROGRAMLISTING">gcc -fpic -c foo.c
gcc -shared -o foo.so foo.o</pre></dd>
<dt><span class="SYSTEMITEM">OpenBSD</span></dt>
<dd><p>创建 PIC 的编译器标志是  <tt class="OPTION">-fpic</tt> 。而 <tt class="LITERAL">ld -Bshareable</tt> 用于链接共享库。</p>
<pre class="PROGRAMLISTING">gcc -fpic -c foo.c
ld -Bshareable -o foo.so foo.o</pre></dd>
<dt><span class="SYSTEMITEM">Solaris</span></dt>
<dd><p>用 Sun 编译器时创建 PIC 的编译器标志是 <tt class="OPTION">-KPIC</tt> ；用 GCC 编译器时创建 PIC 的编译器标志是 <tt class="OPTION">-fpic</tt> 。链接共享库时两个编译器都可以用 <tt class="OPTION">-G</tt> ，此外 GCC 还可以用 <tt class="OPTION">-shared</tt> 。</p>
<pre class="PROGRAMLISTING">cc -KPIC -c foo.c
cc -G -o foo.so foo.o</pre>
<p>或</p>
<pre class="PROGRAMLISTING">gcc -fpic -c foo.c
gcc -G -o foo.so foo.o</pre></dd>
<dt><span class="SYSTEMITEM">Tru64 UNIX</span></dt>
<dd><p>PIC 是缺省，不需要使用特殊的编译器选项。带特殊选项的 <tt class="COMMAND">ld</tt> 用于链接：</p>
<pre class="PROGRAMLISTING">cc -c foo.c
ld -shared -expect_unresolved '*' -o foo.so foo.o</pre>
<p>用 GCC 代替系统编译器时的过程是一样的；不需要特殊的选项。</p></dd>
<dt><span class="SYSTEMITEM">UnixWare</span></dt>
<dd><p>用 SCO 编译器时创建 PIC 的编译器标志是 <tt class="OPTION">-K PIC</tt> ；用 GCC 编译器时创建 PIC 的编译器标志是 <tt class="OPTION">-fpic</tt> 。链接共享库时 SCO 编译器用 <tt class="OPTION">-G</tt> 而 GCC 使用 <tt class="OPTION">-shared</tt> 。</p>
<pre class="PROGRAMLISTING">cc -K PIC -c foo.c
cc -G -o foo.so foo.o</pre>
<p>或</p>
<pre class="PROGRAMLISTING">gcc -fpic -c foo.c
gcc -shared -o foo.so foo.o</pre></dd>
</dl>
</div>
<div class="TIP">
<blockquote class="TIP">
<p><b>【提示】</b>如果你觉得这些步骤实在太复杂，那么你应该考虑使用 <a href="http://www.gnu.org/software/libtool/" target="_top">GNU Libtool</a> ，它把平台的差异隐藏在了一个统一的接口里。</p>
</blockquote>
</div>
<p>生成的共享库文件然后就可以加载到 PostgreSQL 里面去了。在给 <tt class="COMMAND">CREATE FUNCTION</tt> 命令声明文件名的时候，必须声明共享库文件的名字而不是中间目标文件的名字。请注意你可以在 <tt class="COMMAND">CREATE FUNCTION</tt> 命令上忽略系统标准的共享库扩展名(通常是 <tt class="LITERAL">.so</tt> 或 <tt class="LITERAL">.sl</tt>)，并且出于最佳的兼容性考虑也应该忽略。</p>
<p>回头看看<a href="xfunc-c.html#XFUNC-C-DYNLOAD">节33.9.1</a>获取有关服务器预期在哪里找到共享库的信息。</p>
</div>
<div class="SECT2"><h2 class="SECT2"><a name="XFUNC-C-PGXS">33.9.7. 扩展的编译架构</a></h2><a name="AEN37264"></a>
<p>如果你打算发布你的 PostgreSQL 扩展模块，那么给它们设置一个可移植的编译系统可能会相当困难。因此 PostgreSQL 提供了一个 PGXS 架构用于扩展的编译，这样，简单的扩展模块就可以在一个已经安装了的服务器上编译了。这个架构并不打算实现一个统一的编译所有与 PostgreSQL 相关的软件的架构；它只是用于自动化那些简单的服务器扩展模块的编译。对于更复杂的包，还是需要书写你自己的编译系统。</p>
<p>要使用该架构就必须写一个简单的 makefile并在其中设置一些变量，在结尾包括全局的 PGXS makefile 。下面是一个编译 <tt class="LITERAL">isbn_issn</tt> 的例子，它包含一个共享库、一个 SQL 脚本、一个文档。</p>
<pre class="PROGRAMLISTING">MODULES = isbn_issn
DATA_built = isbn_issn.sql
DOCS = README.isbn_issn

PGXS := $(shell pg_config --pgxs)
include $(PGXS)</pre>
<p>最后两行应该总是一样的。你应该在文件的前面赋予变量或者增加自定义的 <span class="APPLICATION">make</span> 规则。</p>
<p>可以设置下列变量：</p>
<div class="VARIABLELIST">
<dl>
<dt><tt class="VARNAME">MODULES</tt></dt>
<dd><p>一个需要从同一个根的源代码上制作的共享对象的列表(不要在这个列表里包含后缀)</p></dd>
<dt><tt class="VARNAME">DATA</tt></dt>
<dd><p>安装到 <tt class="LITERAL"><tt class="REPLACEABLE"><i>prefix</i></tt>/share/contrib</tt> 的随机文件</p></dd>
<dt><tt class="VARNAME">DATA_built</tt></dt>
<dd><p>需要首先制作并安装到 <tt class="LITERAL"><tt class="REPLACEABLE"><i>prefix</i></tt>/share/contrib</tt> 里面的随机文件</p></dd>
<dt><tt class="VARNAME">DOCS</tt></dt>
<dd><p>安装到 <tt class="LITERAL"><tt class="REPLACEABLE"><i>prefix</i></tt>/doc/contrib</tt> 里面的随机文件</p></dd>
<dt><tt class="VARNAME">SCRIPTS</tt></dt>
<dd><p>安装到 <tt class="LITERAL"><tt class="REPLACEABLE"><i>prefix</i></tt>/bin</tt> 里面的脚本文件(非二进制)</p></dd>
<dt><tt class="VARNAME">SCRIPTS_built</tt></dt>
<dd><p>需要首先制作并安装到 <tt class="LITERAL"><tt class="REPLACEABLE"><i>prefix</i></tt>/bin</tt> 里面的脚本文件(非二进制)</p></dd>
<dt><tt class="VARNAME">REGRESS</tt></dt>
<dd><p>回归测试案例的列表(没有后缀)</p></dd>
</dl>
</div>
<p>或者最多声明下面两个之一：</p>
<div class="VARIABLELIST">
<dl>
<dt><tt class="VARNAME">PROGRAM</tt></dt>
<dd><p>一个需要制作的二进制文件(在 <tt class="VARNAME">OBJS</tt> 里面列出目标文件)</p></dd>
<dt><tt class="VARNAME">MODULE_big</tt></dt>
<dd><p>一个需要制作的共享对象(在 <tt class="VARNAME">OBJS</tt> 里列出目标文件)</p></dd>
</dl>
</div>
<p>还可以设置下列变量：</p>
<div class="VARIABLELIST">
<dl>
<dt><tt class="VARNAME">EXTRA_CLEAN</tt></dt>
<dd><p>在 <tt class="LITERAL">make clean</tt> 里删除的额外文件</p></dd>
<dt><tt class="VARNAME">PG_CPPFLAGS</tt></dt>
<dd><p>将增加到 <tt class="VARNAME">CPPFLAGS</tt></p></dd>
<dt><tt class="VARNAME">PG_LIBS</tt></dt>
<dd><p>将增加到 <tt class="VARNAME">PROGRAM</tt> 链接行里</p></dd>
<dt><tt class="VARNAME">SHLIB_LINK</tt></dt>
<dd><p>将增加到 <tt class="VARNAME">MODULE_big</tt> 连接行里</p></dd>
</dl>
</div>
<p>把这个 makefile 以 <tt class="LITERAL">Makefile</tt> 为名保存在扩展的目录里。然后就可以运行 <tt class="LITERAL">make</tt> 来编译，接着用 <tt class="LITERAL">make install</tt> 来安装你的模块。这个扩展是为 <tt class="COMMAND">pg_config</tt> 命令在你的路径里找到的第一个 PostgreSQL 编译和安装的。</p>
<p>在 <tt class="VARNAME">REGRESS</tt> 变量中列出的脚本用于对你的模块进行回归测试，要使测试能够运行必须在你的扩展模块的目录下面建立一个 <tt class="LITERAL">sql/</tt> 子目录，并在其中为期望运行的每组测试放一个文件扩展名为 <tt class="LITERAL">.sql</tt> 的文件，这些文件不应当包含在 <tt class="VARNAME">REGRESS</tt> 列表中。对每个测试都必须在 <tt class="LITERAL">expected/</tt> 子目录中包含一个扩展名为 <tt class="LITERAL">.out</tt> 的期望结果文件。<tt class="LITERAL">make installcheck</tt> 将会运行测试，将输出结果与预设的期望结果文件对比，差异将按照 <tt class="COMMAND">diff -c</tt> 格式写入 <tt class="LITERAL">regression.diffs</tt> 文件。需要注意的是，企图运行一个丢失了期望结果文件的测试将被报告为"trouble"，所以请务必确保所有期望结果文件都存在。</p>
<div class="TIP">
<blockquote class="TIP">
<p><b>【提示】</b>创建期望结果文件最简单的办法是先创建一个空文件，然后小心的检查 <tt class="LITERAL">results/</tt>目录中的测试运行结果，确保正确以后将其复制到 <tt class="LITERAL">expected/</tt> 子目录中。</p>
</blockquote>
</div>
</div>
<div class="SECT2"><h2 class="SECT2"><a name="AEN37384">33.9.8. 复合类型参数</a></h2>
<p>复合类型不像 C 结构那样有固定的布局。复合类型的实例可能包含空(NULL)字段。另外，一个属于继承层次一部分的复合类型可能和同一继承范畴的其它成员有不同的域/字段。因此，PostgreSQL 提供一个过程接口用于从 C 中访问复合类型。</p>
<p>假设为下面查询写一个函数</p>
<pre class="PROGRAMLISTING">SELECT name, c_overpaid(emp, 1500) AS overpaid
    FROM emp
    WHERE name = 'Bill' OR name = 'Sam';</pre>
<p>在上面的查询里，用版本-0 可以这样定义 <code class="FUNCTION">c_overpaid</code> ：</p>
<pre class="PROGRAMLISTING">#include "postgres.h"
#include "executor/executor.h"  /* 使用 GetAttributeByName() */

bool
c_overpaid(HeapTupleHeader t, /* emp 的当前行 */
           int32 limit)
{
    bool isnull;
    int32 salary;

    salary = DatumGetInt32(GetAttributeByName(t, "salary", &amp;isnull));
    if (isnull)
        return false;
    return salary &gt; limit;
}</pre>
<p>如果用版本-1 则会写成下面这样：</p>
<pre class="PROGRAMLISTING">#include "postgres.h"
#include "executor/executor.h"  /* 使用 GetAttributeByName() */

PG_FUNCTION_INFO_V1(c_overpaid);

Datum
c_overpaid(PG_FUNCTION_ARGS)
{
    HeapTupleHeader  t = PG_GETARG_HEAPTUPLEHEADER(0);
    int32            limit = PG_GETARG_INT32(1);
    bool isnull;
    Datum salary;

    salary = GetAttributeByName(t, "salary", &amp;isnull);
    if (isnull)
        PG_RETURN_BOOL(false);
    /* 另外，可能更希望将 PG_RETURN_NULL() 用在 null 薪水上 */

    PG_RETURN_BOOL(DatumGetInt32(salary) &gt; limit);
}</pre>
<p><code class="FUNCTION">GetAttributeByName</code> 是 PostgreSQL 系统函数，用来返回当前记录的字段。它有三个参数：类型为 <tt class="TYPE">HeapTupleHeader</tt> 的传入函数的参数、你想要的字段名称、一个确定字段是否为 NULL 的返回参数。<code class="FUNCTION">GetAttributeByName</code> 函数返回一个 <tt class="TYPE">Datum</tt> 值，你可以用对应的 <code class="FUNCTION">DatumGet<tt class="REPLACEABLE"><i>XXX</i></tt>()</code> 宏把它转换成合适的数据类型。请注意，如果设置了 NULL 标志，那么返回值是无意义的，在准备对结果做任何处理之前，总是要先检查 NULL 标志。</p>
<p>还有一个 <code class="FUNCTION">GetAttributeByNum</code> 用字段编号而不是字段名选取目标字段。</p>
<p>下面的命令在 SQL 里声明 <code class="FUNCTION">c_overpaid</code> 函数：</p>
<pre class="PROGRAMLISTING">CREATE FUNCTION c_overpaid(emp, integer) RETURNS boolean
    AS '<tt class="REPLACEABLE"><i>DIRECTORY</i></tt>/funcs', 'c_overpaid'
    LANGUAGE C STRICT;</pre>
<p>请注意使用 <tt class="LITERAL">STRICT</tt> 后就不需要检查输入参数是否有 NULL 。</p>
</div>
<div class="SECT2"><h2 class="SECT2"><a name="AEN37408">33.9.9. 返回行(复合类型)</a></h2>
<p>要从一个 C 语言函数里返回一个行或复合类型的数值，可以使用一个特殊的 API ，它提供了许多宏和函数来消除大多数制作复合数据类型的复杂性。要使用该 API ，源代码必须包含：</p>
<pre class="PROGRAMLISTING">#include "funcapi.h"</pre>
<p>制作一个复合类型数据值(也就是一个"行")有两种方法：你可以从一个 Datum 值数组里制作，也可以从一个可以传递给该行的字段类型的输入转换函数的 C 字符串数组里制作。不管是哪种方式，你首先都需要为行结构获取或者制作一个 <tt class="STRUCTNAME">TupleDesc</tt> 描述符。在使用 Datums 的时候，你给 <code class="FUNCTION">BlessTupleDesc</code> 传递这个 <tt class="STRUCTNAME">TupleDesc</tt> 然后为每行调用 <code class="FUNCTION">heap_form_tuple</code> 。在使用 C 字符串的时候，你给 <code class="FUNCTION">TupleDescGetAttInMetadata</code> 传递 <tt class="STRUCTNAME">TupleDesc</tt> ，然后为每行调用 <code class="FUNCTION">BuildTupleFromCStrings</code> 。如果是返回一个行集合的场合，所有设置步骤都可以在第一次调用该函数的时候一次性完成。</p>
<p>有几个便利函数可以用于设置所需要的 <tt class="STRUCTNAME">TupleDesc</tt> 。在大多数返回复合类型给调用者的函数里建议的做法是这样的：</p>
<pre class="PROGRAMLISTING">TypeFuncClass get_call_result_type(FunctionCallInfo fcinfo,
                                   Oid *resultTypeId,
                                   TupleDesc *resultTupleDesc)</pre>
<p>把传递给调用函数自己的 <tt class="LITERAL">fcinfo</tt> 传递给它(要求使用版本-1 的调用习惯)。<tt class="VARNAME">resultTypeId</tt> 可以声明为 <tt class="LITERAL">NULL</tt> 或者接收函数的结果类型 OID 的局部变量地址(指针)。<tt class="VARNAME">resultTupleDesc</tt> 应该是一个局部的 <tt class="STRUCTNAME">TupleDesc</tt> 变量地址(指针)。检查结果是否 <tt class="LITERAL">TYPEFUNC_COMPOSITE</tt> ；如是，<tt class="VARNAME">resultTupleDesc</tt> 就已经填充好需要的 <tt class="STRUCTNAME">TupleDesc</tt> 了。如果不是，你可以报告一个类似"返回记录的函数在一个不接受记录的环境中被调用"的错误。</p>
<div class="TIP">
<blockquote class="TIP">
<p><b>【提示】</b><code class="FUNCTION">get_call_result_type</code> 可以把一个多态的函数结果解析为实际类型；因此它在返回多态的标量结果的函数里也很有用，而不仅仅是返回复合类型的函数里。<tt class="VARNAME">resultTypeId</tt> 输出主要用于那些返回多态的标量类型的函数。</p>
</blockquote>
</div>
<div class="NOTE">
<blockquote class="NOTE">
<p><b>【注意】</b><code class="FUNCTION">get_call_result_type</code> 有一个同胞弟兄 <code class="FUNCTION">get_expr_result_type</code> 可以用于给一个用表达式树表示的函数调用解析输出，它可以用于视图从函数本身外边判断结果类型的场合。还有一个 <code class="FUNCTION">get_func_result_type</code> 可以用在只能拿到函数 OID 的场合。不过，这些函数不能处理那些声明为返回 <tt class="STRUCTNAME">record</tt> 的函数，并且 <code class="FUNCTION">get_func_result_type</code> 不能解析多态的类型，因此你最好还是使用 <code class="FUNCTION">get_call_result_type</code> 。</p>
</blockquote>
</div>
<p>旧的，现在已经废弃的获取 <tt class="STRUCTNAME">TupleDesc</tt> 的函数是</p>
<pre class="PROGRAMLISTING">TupleDesc RelationNameGetTupleDesc(const char *relname)</pre>
<p>它可以从一个命名的关系里为行类型获取一个 <tt class="STRUCTNAME">TupleDesc</tt> ，还有</p>
<pre class="PROGRAMLISTING">TupleDesc TypeGetTupleDesc(Oid typeoid, List *colaliases)</pre>
<p>可以基于类型 OID 获取一个 <tt class="STRUCTNAME">TupleDesc</tt> 。它可以用于给一个基本类型或者一个复合类型获取 <tt class="STRUCTNAME">TupleDesc</tt> 。不过它不能处理返回 <tt class="STRUCTNAME">record</tt> 的函数，并且不能解析多态的类型。</p>
<p>一旦你有了一个 <tt class="STRUCTNAME">TupleDesc</tt> ，如果你想使用 Datum ，那么调用</p>
<pre class="PROGRAMLISTING">TupleDesc BlessTupleDesc(TupleDesc tupdesc)</pre>
<p>如果你想用 C 字符串，那么调用</p>
<pre class="PROGRAMLISTING">AttInMetadata *TupleDescGetAttInMetadata(TupleDesc tupdesc)</pre>
<p>如果你在写一个返回集合的函数，那么你可以把这些函数的结果保存在 <tt class="STRUCTNAME">FuncCallContext</tt> 结构里(分别使用 <tt class="STRUCTFIELD">tuple_desc</tt> 或 <tt class="STRUCTFIELD">attinmeta</tt> 字段)。</p>
<p>在使用 Datum 的时候，使用</p>
<pre class="PROGRAMLISTING">HeapTuple heap_form_tuple(TupleDesc tupdesc, Datum *values, bool *isnull)</pre>
<p>制作一个 <tt class="STRUCTNAME">HeapTuple</tt> ，它把数据以 Datum 的形式交给用户。</p>
<p>在使用 C 字符串的时候，用</p>
<pre class="PROGRAMLISTING">HeapTuple BuildTupleFromCStrings(AttInMetadata *attinmeta, char **values)</pre>
<p>制作一个 <tt class="STRUCTNAME">HeapTuple</tt> ，以 C 字符串的形式给出用户数据。<tt class="LITERAL">values</tt> 是一个 C 字符串的数组，返回行的每个字段对应其中一个。每个 C 字符串都应该是字段数据类型的输入函数预期的形式。为了从其中一个字段中返回一个 NULL ，<tt class="PARAMETER">values</tt> 数组中对应的指针应该设置为 <tt class="SYMBOL">NULL</tt> 。这个函数将会需要为你返回的每个行调用一次。</p>
<p>一旦你制作了一个从你的函数中返回的行，那么该行必须转换成一个 <tt class="TYPE">Datum</tt> 。使用</p>
<pre class="PROGRAMLISTING">HeapTupleGetDatum(HeapTuple tuple)</pre>
<p>把一个 <tt class="STRUCTNAME">HeapTuple</tt> 转换为一个有效的 Datum 。如果你想只返回一行，那么这个 <tt class="TYPE">Datum</tt> 可以用于直接返回，或者是它可以用作在一个返回集合的函数里的当前返回值。</p>
<p>例子在下面给出。</p>
</div>
<div class="SECT2"><h2 class="SECT2"><a name="XFUNC-C-RETURN-SET">33.9.10. 返回集合</a></h2>
<p>还有一个特殊的 API 用于提供从 C 语言函数中返回集合(多行)。一个返回集合的函数必须遵循版本-1 的调用方式。同样，源代码必须包含 <tt class="FILENAME">funcapi.h</tt> ，就像上面说的那样。</p>
<p>一个返回集合的函数(SRF)通常为它返回的每个项都调用一次。因此 SRF 必须保存足够的状态用于记住它正在做的事情以及在每次调用的时候返回下一个项。表函数 API 提供了 <tt class="STRUCTNAME">FuncCallContext</tt> 结构用于帮助控制这个过程。<tt class="LITERAL">fcinfo-&gt;flinfo-&gt;fn_extra</tt> 用于保存一个跨越多次调用的指向 <tt class="STRUCTNAME">FuncCallContext</tt> 的指针。</p>
<pre class="PROGRAMLISTING">typedef struct
{
    /*
     * 前面已经被调用的次数
     * 初始的时候，call_cntr 被 SRF_FIRSTCALL_INIT() 置为 0，并且每次你调用 SRF_RETURN_NEXT() 的时候都递增
     */
    uint32 call_cntr;

    /*
     * 可选的最大调用数量
     * 这里的 max_calls 只是为了方便，设置它也是可选的
     * 如果没有设置，你必须提供可选的方法来知道函数何时结束
     */
    uint32 max_calls;

    /*
     * 指向结果槽位的可选指针
     * 这个数据类型已经过时，只用于向下兼容。也就是那些使用已废弃的 TupleDescGetSlot() 的用户定义 SRF
     */
    TupleTableSlot *slot;

    /*
     * 可选的指向用户提供的杂项环境信息的指针
     * user_fctx 用做一个指向你自己的结构的指针，包含任意提供给你的函数的调用间的环境信息
     */
    void *user_fctx;

    /*
     * 可选的指向包含属性类型输入元信息的结构数组的指针
     * attinmeta 用于在返回行的时候(也就是说返回复合数据类型)
     * 在只返回基本(也就是标量)数据类型的时候并不需要。
     * 只有在你准备用 BuildTupleFromCStrings() 创建返回行的时候才需要它
     */
    AttInMetadata *attinmeta;

    /*
     * 用于必须在多次调用间存活的结构的内存环境
     *
     * multi_call_memory_ctx 是由 SRF_FIRSTCALL_INIT() 为你设置的，并且由 SRF_RETURN_DONE() 用于清理。
     * 它是用于存放任何需要跨越多次调用 SRF 之间重复使用的内存
     */
    MemoryContext multi_call_memory_ctx;

    /*
     * 可选的指针，指向包含行描述的结构
     *
     * tuple_desc 用于返回行(也就是说复合数据类型)并且只是在你想使用 heap_form_tuple() 而不是 BuildTupleFromCStrings() 制作行的时候需要。
     * 请注意这里存储的 TupleDesc 指针通常应该先用 BlessTupleDesc() 处理。
     */
    TupleDesc tuple_desc;

} FuncCallContext;</pre>
<p>一个 SRF 使用自动操作 <tt class="STRUCTNAME">FuncCallContext</tt> 结构(可以通过 <tt class="LITERAL">fn_extra</tt> 找到)的若干个函数和宏。用</p>
<pre class="PROGRAMLISTING">SRF_IS_FIRSTCALL()</pre>
<p>来判断你的函数是第一次调用还是后继的调用。只有在第一次调用的时候，用</p>
<pre class="PROGRAMLISTING">SRF_FIRSTCALL_INIT()</pre>
<p>初始化 <tt class="STRUCTNAME">FuncCallContext</tt> 。在每次函数调用时(包括第一次)，使用</p>
<pre class="PROGRAMLISTING">SRF_PERCALL_SETUP()</pre>
<p>为使用 <tt class="STRUCTNAME">FuncCallContext</tt> 做恰当的设置以及清理任何前面的轮回里面剩下的已返回的数据。</p>
<p>如果你的函数有数据要返回，使用</p>
<pre class="PROGRAMLISTING">SRF_RETURN_NEXT(funcctx, result)</pre>
<p>返回给调用者(<tt class="LITERAL">result</tt> 必须是个 <tt class="TYPE">Datum</tt> ，要么是单个值，要么是像前面介绍的那样准备的行)。最后，如果你的函数结束了数据返回，使用</p>
<pre class="PROGRAMLISTING">SRF_RETURN_DONE(funcctx)</pre>
<p>清理并结束 SRF 。</p>
<p>在 SRF 被调用时的内存环境是一个临时环境，在调用之间将会被清理掉。这意味着你不需要 <code class="FUNCTION">pfree</code> 所有你 <code class="FUNCTION">palloc</code> 的东西；它会自动消失的。不过，如果你想分配任何跨越调用存在的数据结构，那你就需要把它们放在其它什么地方。被 <tt class="STRUCTFIELD">multi_call_memory_ctx</tt> 引用的环境适合用于保存那些需要直到 SRF 结束前都存活的数据。在大多数情况下，这意味着你在第一次调用设置的时候应该切换到 <tt class="STRUCTFIELD">multi_call_memory_ctx</tt> 。</p>
<p>一个完整的伪代码例子看起来像下面这样：</p>
<pre class="PROGRAMLISTING">Datum
my_set_returning_function(PG_FUNCTION_ARGS)
{
    FuncCallContext  *funcctx;
    Datum             result;
    MemoryContext     oldcontext;
    <tt class="REPLACEABLE"><i>更多的声明</i></tt>

    if (SRF_IS_FIRSTCALL())
    {
        funcctx = SRF_FIRSTCALL_INIT();
        oldcontext = MemoryContextSwitchTo(funcctx-&gt;multi_call_memory_ctx);
        /* 这里放出现一次的设置代码： */
        <tt class="REPLACEABLE"><i>用户定义代码</i></tt>
        <tt class="REPLACEABLE"><i>if 返回复合</i></tt>
            <tt class="REPLACEABLE"><i>制作 TupleDesc 以及可能还有 AttInMetadata</i></tt>
        <tt class="REPLACEABLE"><i>endif 返回复合</i></tt>
        <tt class="REPLACEABLE"><i>用户定义代码</i></tt>
        MemoryContextSwitchTo(oldcontext);
    }

    /* 每次都执行的设置代码在这里出现： */
    <tt class="REPLACEABLE"><i>用户定义代码</i></tt>
    funcctx = SRF_PERCALL_SETUP();
    <tt class="REPLACEABLE"><i>用户定义代码</i></tt>

    /* 这里只是用来测试是否完成的一个方法： */
    if (funcctx-&gt;call_cntr &lt; funcctx-&gt;max_calls)
    {
        /* 这里想返回另外一个条目： */
        <tt class="REPLACEABLE"><i>用户代码</i></tt>
        <tt class="REPLACEABLE"><i>获取结果 Datum</i></tt>
        SRF_RETURN_NEXT(funcctx, result);
    }
    else
    {
        /* 这里完成返回条目的工作了，只需要清理就 OK 了： */
        <tt class="REPLACEABLE"><i>用户代码</i></tt>
        SRF_RETURN_DONE(funcctx);
    }
}</pre>
<p>一个返回复合类型的完整 SRF 例子看起来像这样：</p>
<pre class="PROGRAMLISTING">PG_FUNCTION_INFO_V1(retcomposite);

Datum
retcomposite(PG_FUNCTION_ARGS)
{
    FuncCallContext     *funcctx;
    int                  call_cntr;
    int                  max_calls;
    TupleDesc            tupdesc;
    AttInMetadata       *attinmeta;

     /* 只是在第一次调用函数的时候干的事情 */
     if (SRF_IS_FIRSTCALL())
     {
        MemoryContext   oldcontext;

        /* 创建一个函数环境，用于在调用间保持住 */
        funcctx = SRF_FIRSTCALL_INIT();

        /* 切换到适合多次函数调用的内存环境 */
        oldcontext = MemoryContextSwitchTo(funcctx-&gt;multi_call_memory_ctx);

        /* 要返回的行总数 */
        funcctx-&gt;max_calls = PG_GETARG_UINT32(0);

        /* 为的结果类型制作一个行描述 */
        if (get_call_result_type(fcinfo, NULL, &amp;tupdesc) != TYPEFUNC_COMPOSITE)
            ereport(ERROR,
                    (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
                     errmsg("function returning record called in context "
                            "that cannot accept type record")));

        /* 生成稍后从裸 C 字符串生成行的属性元数据 */
        attinmeta = TupleDescGetAttInMetadata(tupdesc);
        funcctx-&gt;attinmeta = attinmeta;

        MemoryContextSwitchTo(oldcontext);
    }

    /* 每次函数调用都要做的事情 */
    funcctx = SRF_PERCALL_SETUP();

    call_cntr = funcctx-&gt;call_cntr;
    max_calls = funcctx-&gt;max_calls;
    attinmeta = funcctx-&gt;attinmeta;
 
    if (call_cntr &lt; max_calls)    /* 在还有需要发送的东西时继续处理 */
    {
        char       **values;
        HeapTuple    tuple;
        Datum        result;

        /*
         * 准备一个数值数组用于版本的返回行。
         * 它应该是一个C字符串数组，稍后可以被合适的类型输入函数处理。
         */
        values = (char **) palloc(3 * sizeof(char *));
        values[0] = (char *) palloc(16 * sizeof(char));
        values[1] = (char *) palloc(16 * sizeof(char));
        values[2] = (char *) palloc(16 * sizeof(char));

        snprintf(values[0], 16, "%d", 1 * PG_GETARG_INT32(1));
        snprintf(values[1], 16, "%d", 2 * PG_GETARG_INT32(1));
        snprintf(values[2], 16, "%d", 3 * PG_GETARG_INT32(1));

        /* 制作一个行 */
        tuple = BuildTupleFromCStrings(attinmeta, values);

        /* 把行做成 datum */
        result = HeapTupleGetDatum(tuple);

        /* 清理(这些实际上并非必要) */
        pfree(values[0]);
        pfree(values[1]);
        pfree(values[2]);
        pfree(values);

        SRF_RETURN_NEXT(funcctx, result);
    }
    else    /* 在没有数据残留的时候干的事情 */
    {
        SRF_RETURN_DONE(funcctx);
    }
}</pre>
<p>在 SQL 里声明这个函数的一个方法是：</p>
<pre class="PROGRAMLISTING">CREATE TYPE __retcomposite AS (f1 integer, f2 integer, f3 integer);

CREATE OR REPLACE FUNCTION retcomposite(integer, integer)
    RETURNS SETOF __retcomposite
    AS '<tt class="REPLACEABLE"><i>filename</i></tt>', 'retcomposite'
    LANGUAGE C IMMUTABLE STRICT;</pre>
<p>另外一个方法是使用 OUT 参数：</p>
<pre class="PROGRAMLISTING">CREATE OR REPLACE FUNCTION retcomposite(IN integer, IN integer,
    OUT f1 integer, OUT f2 integer, OUT f3 integer)
    RETURNS SETOF record
    AS '<tt class="REPLACEABLE"><i>filename</i></tt>', 'retcomposite'
    LANGUAGE C IMMUTABLE STRICT;</pre>
<p>请注意在这个方法里，函数的输出类型实际上是匿名的 <tt class="STRUCTNAME">record</tt> 类型。</p>
<p>参阅源码发布包里的 <tt class="FILENAME">contrib/tablefunc</tt> 获取更多有关返回集合的函数的例子。</p>
</div>
<div class="SECT2"><h2 class="SECT2"><a name="AEN37531">33.9.11. 多态参数和返回类型</a></h2>
<p>C 语言函数可以声明为接受和返回多态的类型 <tt class="TYPE">anyelement</tt> 和 <tt class="TYPE">anyarray</tt> 。参阅<a href="extend-type-system.html#EXTEND-TYPES-POLYMORPHIC">节33.2.5</a>获取有关多态函数的更详细解释。如果函数参数或者返回类型定义为多态类型，那么函数的作者就无法预先知道他将收到的参数，以及需要返回的数据。在 <tt class="FILENAME">fmgr.h</tt> 里有两个过程，可以让版本-1 的 C 函数知道它的参数的确切数据类型以及它需要返回的数据类型。这两个过程叫 <tt class="LITERAL">get_fn_expr_rettype(FmgrInfo *flinfo)</tt> 和 <tt class="LITERAL">get_fn_expr_argtype(FmgrInfo *flinfo, int argnum)</tt> 。它们返回结果或者参数的类型 OID ，如果这些信息不可获取，则返回 <tt class="SYMBOL">InvalidOid</tt> 。结构 <tt class="LITERAL">flinfo</tt> 通常是以 <tt class="LITERAL">fcinfo-&gt;flinfo</tt> 进行访问的。参数 <tt class="LITERAL">argnum</tt> 是以 0 为基的。<code class="FUNCTION">get_call_result_type</code> 也可以替代 <code class="FUNCTION">get_fn_expr_rettype</code> 。</p>
<p>比如，假设想写一个函数接受任意类型的一个元素，并且返回该类型的一个一维数组：</p>
<pre class="PROGRAMLISTING">PG_FUNCTION_INFO_V1(make_array);
Datum
make_array(PG_FUNCTION_ARGS)
{
    ArrayType  *result;
    Oid         element_type = get_fn_expr_argtype(fcinfo-&gt;flinfo, 0);
    Datum       element;
    bool        isnull;
    int16       typlen;
    bool        typbyval;
    char        typalign;
    int         ndims;
    int         dims[MAXDIM];
    int         lbs[MAXDIM];

    if (!OidIsValid(element_type))
        elog(ERROR, "could not determine data type of input");

    /* 获取提供的元素(要小心其为 NULL 的情况) */
    isnull = PG_ARGISNULL(0);
    if (isnull)
        element = (Datum) 0;
    else
        element = PG_GETARG_DATUM(0);

    /* 维数是 1 */
    ndims = 1;
    /* 有一个元素 */
    dims[0] = 1;
    /* 数组下界是 1 */
    lbs[0] = 1;

    /* 获取有关元素类型需要的信息 */
    get_typlenbyvalalign(element_type, &amp;typlen, &amp;typbyval, &amp;typalign);

    /* 然后制作数组 */
    result = construct_md_array(&amp;element, &amp;isnull, ndims, dims, lbs,
                                element_type, typlen, typbyval, typalign);

    PG_RETURN_ARRAYTYPE_P(result);
}</pre>
<p>下面的命令用SQL声明 <code class="FUNCTION">make_array</code> 函数：</p>
<pre class="PROGRAMLISTING">CREATE FUNCTION make_array(anyelement) RETURNS anyarray
    AS '<tt class="REPLACEABLE"><i>DIRECTORY</i></tt>/funcs', 'make_array'
    LANGUAGE C IMMUTABLE;</pre>
</div>
<div class="SECT2"><h2 class="SECT2"><a name="AEN37552">33.9.12. 共享内存和 LWLock</a></h2>
<p>插件可能保留 LWLocks 并在服务器启动时分配共享内存。插件的共享库必须通过指定 <a href="runtime-config-resource.html#GUC-SHARED-PRELOAD-LIBRARIES">shared_preload_libraries</a> 的方法预先加载。共享内存可以通过在 <code class="FUNCTION">_PG_init</code> 函数中调用</p>
<pre class="PROGRAMLISTING">void RequestAddinShmemSpace(int size)</pre>
<p>保留。</p>
<p>LWLocks 可以通过在 <code class="FUNCTION">_PG_init</code> 中调用</p>
<pre class="PROGRAMLISTING">void RequestAddinLWLocks(int n)</pre>
<p>保留。</p>
<p>为了避免可能出现的竞争条件，每一个后端都应当在连接并初始化其共向内存时使用 LWLock <code class="FUNCTION">AddinShmemInitLock</code> ，示范如下：</p>
<pre class="PROGRAMLISTING">        static mystruct *ptr = NULL;

        if (!ptr)
        {
                bool    found;

                LWLockAcquire(AddinShmemInitLock, LW_EXCLUSIVE);
                ptr = ShmemInitStruct("my struct name", size, &amp;found);
                if (!ptr)
                        elog(ERROR, "out of shared memory");
                if (!found)
                {
                        initialize contents of shmem area;
                        acquire any requested LWLocks using:
                        ptr-&#62;mylockid = LWLockAssign();
                }
                LWLockRelease(AddinShmemInitLock);
        }</pre>
</div>
</div>
<div>
<hr align="LEFT" width="100%">
<table summary="Footer navigation table" width="100%" border="0" cellpadding="0" cellspacing="0">
<tr><td width="33%" align="left" valign="top"><a href="xfunc-internal.html" accesskey="P">后退</a></td><td width="34%" align="center" valign="top"><a href="index.html" accesskey="H">首页</a></td><td width="33%" align="right" valign="top"><a href="xaggr.html" accesskey="N">前进</a></td></tr>
<tr><td width="33%" align="left" valign="top">内部函数</td><td width="34%" align="center" valign="top"><a href="extend.html" accesskey="U">上一级</a></td><td width="33%" align="right" valign="top">用户定义聚集</td></tr>
</table>
</div>
</body></html>